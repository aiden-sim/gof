## 팩토리 메소드 패턴
- 구체적으로 어떤 인스턴스를 만들지는 서브 클래스가 정한다.

- BlackShip을 생산했다가 WhiteShip에 대한 주문이 들어 온다면?
  - 코드 내부에서 if/else 로 분기가 계속 생길것이다.
- 그러다가 여러 종류의 배가 추가된다면?
  - Concrete class에 담아두기 복잡해 진다

- 해결책은?
  - 추상화된 팩토리를 만든다.
  
- 구조
  - ![스크린샷 2021-12-13 오후 11 18 21](https://user-images.githubusercontent.com/7076334/145828781-985d2ec3-c7d5-457a-a204-e50a51309805.png)
  - 여기서는 인터페이스 default 메서드를 이용해서 기본 기능 구현 하고 변경되는 부분만 ConcreteCreator에서 구현 (템플릿 메서드)
  - 확장한 유연한 구조로 만들어 진다.

## Before

```
public class ShipFactory {

    public static Ship orderShip(String name, String email) {
        // validate
        if (name == null || name.isBlank()) {
            throw new IllegalArgumentException("배 이름을 지어주세요.");
        }
        if (email == null || email.isBlank()) {
            throw new IllegalArgumentException("연락처를 남겨주세요.");
        }

        prepareFor(name);

        Ship ship = new Ship();
        ship.setName(name);

        // Customizing for specific name
        if (name.equalsIgnoreCase("whiteship")) {
            ship.setLogo("\uD83D\uDEE5️");
        } else if (name.equalsIgnoreCase("blackship")) {
            ship.setLogo("⚓");
        }

        // coloring
        if (name.equalsIgnoreCase("whiteship")) {
            ship.setColor("whiteship");
        } else if (name.equalsIgnoreCase("blackship")) {
            ship.setColor("black");
        }

        // notify
        sendEmailTo(email, ship);

        return ship;
    }

    private static void prepareFor(String name) {
        System.out.println(name + " 만들 준비 중");
    }

    private static void sendEmailTo(String email, Ship ship) {
        System.out.println(ship.getName() + " 다 만들었습니다.");
    }

}


public class Ship {

    private String name;

    private String color;

    private String logo;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getColor() {
        return color;
    }

    public void setColor(String color) {
        this.color = color;
    }

    public String getLogo() {
        return logo;
    }

    public void setLogo(String logo) {
        this.logo = logo;
    }

    @Override
    public String toString() {
        return "Ship{" +
                "name='" + name + '\'' +
                ", color='" + color + '\'' +
                ", logo='" + logo + '\'' +
                '}';
    }
}

```
- 만약 새로운 제품이 추가 된다면? 요구사항에 따라서 제품(Ship)의 항목들이 변경될 수 있다.
  - OCP 위배 (변경에 닫혀 있지 않다.)


## after
```
/**
 * Creator
 */
public interface ShipFactory {

    default Ship orderShip(String name, String email) {
        validate(name, email);
        prepareFor(name);
        Ship ship = createShip();
        sendEmailTo(email, ship);
        return ship;
    }

    void sendEmailTo(String email, Ship ship);

    Ship createShip();

    private void validate(String name, String email) {
        if (name == null || name.isBlank()) {
            throw new IllegalArgumentException("배 이름을 지어주세요.");
        }
        if (email == null || email.isBlank()) {
            throw new IllegalArgumentException("연락처를 남겨주세요.");
        }
    }

    private void prepareFor(String name) {
        System.out.println(name + " 만들 준비 중");
    }

}

}


/**
 * ConcreateCreator
 */
public class WhiteshipFactory extends DefaultShipFactory {

    @Override
    public Ship createShip() {
        return new Whiteship();
    }
}


/**
 * Proudction
 */
public class Ship {

    private String name;

    private String color;

    private String logo;

    private Wheel wheel;

    private Anchor anchor;


/**
 * ConcreteProudction
 */
public class Whiteship extends Ship {

    public Whiteship() {
        setName("whiteship");
        setLogo("\uD83D\uDEE5️");
        setColor("white");
    }
}

```



## 추상 팩토리 패턴

## 빌더 패턴
