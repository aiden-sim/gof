# 행동 패턴
- 어떤 처리의 책임을 어느 객체에 할당하는 것이 좋은지, 알고리즘을 어느 객체에 정의하는 것이 좋은지 등을 다룸
- 행동 패턴은 객체나 클래스에 대한 패턴을 정의하는 것이 아니고, 그들 간의 교류 방법에 대하여 정의
- 행동 패턴을 사용하면 우리는 객체 간의 제어 구조보다는 객체들을 어떻게 연결시킬 것인가에 좀더 중점

- 상속 행동 패턴
  - 1) 템플릿 메서드 패턴
    - 알고리즘에 대한 추상화된 정의로, 알고리즘을 한 단계씩 정의
    - 각 단계는 추상 연산 또는 기본 연산 중 하나 (기본 연산은 자신이 처리 내용을 정의하고 구현 내용을 확정한 연산을 의미)
    - 추상 메서드의 실제 구체적인 구현은 서브클래스가 정의
  - 2) 해석자 패턴
    - 문법을 클래스 계통으로 구성하고 이 클래스들의 인스턴스에 대한 연산으로서 해석자를 구현 

- 복합 행동 패턴
  - 하나의 객체가 스스로 모든 처리를 하는 것이 아니라, 관련된 객체들이 하나의 처리를 책임지는 방법
  - 1) 중재자 패턴
    - 관련된 객체 집합 사이의 중재자로 새로운 객체를 하나 도입함으로써 이 상황(필요한 객체를 직접 참조해야되는 상황)을 피하게 해줌
    - 중재자 객체가 관련 객체 간의 처리를 담당함으로써, 객체 간의 결합도가 느슨해질 수 있음
  - 2) 책임 연쇄 패턴
    - 결합도를 좀 더 약화시키는 효과를 줌
    - 한 객체에게 보낸 메시지가 내부적으로 연결된 다른 객체에게 자동으로 전달
    - 메시지를 받은 객체는 런타임 조건에 따라서 메시지를 처리할 것인지 결정
  - 3) 감시자 패턴
    - 객체 간의 종속성을 정의하고 관리하는 패턴
    - 스몰토크 언어 MVC에서 사용
      - 모델이 변경되면, 모델과 관련된 모든 뷰에 그 변경 사실 통지  

  - 행동을 객체로 어떻게 잘 감쌀 것인지, 또 자신이 메시지를 처리할 것인지 아니면 다른 객체에게 위임할 것인지 등에 관련
  - 4) 전략 패턴
    - 알고리즘을 객체로 만들어 그것을 캡슐화
    - 알고리즘(행동)을 별도 객체로 분리함으로써, 알고리즘이 바뀔 때 해당 알고리즘 객체를 변경 또는 추가해서 이를 사용하는 곳에서는 아무 변화 없이 사용할 수 있도록 해줌 
  - 5) 명령 패턴
    - 요청 자체를 객체로 만들어서 이 객체를 매개변수로 넘기거나 수행한 명령 리스트에 저장하는 방식으로 사용 
  - 6) 상태 패턴
    - 객체의 상태를 또 다른 객체로 정의하여 객체의 상태가 바뀌면 이에 대항하는 객체를 변경할 수 있도록 함 
  - 7) 방문자 패턴
    - 하나의 행동을 여러 클래스에 걸쳐서 분산할 수 있게 해줌 
  - 8) 반복자 패턴
    - 모든 객체들을 순회하거나 차례로 접근하는 방법을 제공


# 책임 연쇄(CHAIN OF RESPONSIBILITY)
## 의도
- 메시지를 보내는 객체와 이를 받아 처리하는 객체들 간의 결합도를 없애기 위한 패턴
- 하나의 요청에 대한 처리가 반드시 한 객체에서만 되지 않고, 여러 객체에게 그 처리 기회를 줌

## 동기
- 그래픽 사용자 인터페이스(GUI)에 있는 문맥 감지 도움말 기능
  - 사용자가 정보를 선택하면 그 부분에 대한 도움말 정보를 얻을 수 있음
  - 선택한 주체에 대한 구체적인 도움말이 없다면, 도움말 시스템은 적어도 응용프로그램이 정의한 일반적인 도움말이라도 제공할 수 있어야 함
  - 어느 정도의 구체적인 도움말이 가능한가에 따라 여러 인터페이스 중 하나가 이 요청을 처리할 수 있음
  - 하지만, 요청을 일으키는 객체는 실제로 자신에게 해당 도움말을 제공하는 객체가 누구인지 알 수 없음
  - 이를 위해 도움말 요청을 발생시키는 버튼과 도움말 정보를 제공하는 객체를 분리해야 할 필요가 있음
    - 이 부분의 기작을 정의하는 패턴이 책임 연쇄 패턴 

- 책임 연쇄 패턴의 아이디어는 메시지 송신 측과 수신측을 분리하는 것
  - 송신(보내는)하는 측이 자신이 아는 주체에게 처리를 요청하면, 이를 수신한 객체가 자신과 연결된 고리를 따라서 계속 이 요청을 전달
  - 이 중에 어느 한 객체가 실제 상황에 적합하다고 판단되면 자신에게 정의된 서비스를 제공

- ![chain1](https://user-images.githubusercontent.com/7076334/137943545-3920b292-1230-488f-895b-c244ab24fbf4.png)
  - 사용자는 요청을 발생하기는 했지만, 이 요청을 궁극적으로 처리할 객체의 직접적인 참조자는 없음
  - 사용자는 그저 PrintButton에 메시지를 보냈을 뿐
  - 연결 고리를 따라 요청을 계속 전달할 수 있어야 하고, 메시지 수신 객체를 명시할 수 없는 상황을 고려한다면, 객체의 연결 고리에 존재하는 객체는 누구든지 동일한 요청을 처리할 수 있어야 함
    - 공통의 인터페이스를 가져가야 함

## 활용성
- 책임 연쇄 패턴은 다음의 경우에 사용
  - 하나 이상의 객체가 요청을 처리해야 하고, 그 요청 처리자 중 어떤 것이 선행자인지 모를 때. 처리자가 자동으로 확정되어야 함
  - 메시지를 받을 객체를 명시하지 않은 채 여러 객체 중 하나에게 처리를 요청하고 싶을 때
  - 요청을 처리할 수 있는 객체 집합이 동적으로 정의되어야 할 때

## 구조
- ![chain3](https://user-images.githubusercontent.com/7076334/137946061-c54e3d65-383e-4330-a5a2-a71f6c6d7189.png)

## 참여자
- Handler(HelpHandler) :
  - 요청을 처리하는 인터페이스를 정의하고, 후속 처리자(successor)와 연결을 구현
  - 즉, 연결 고리에 연결된 다음 객체에게 다시 메시지를 보냄
- ConcreteHandler(PrintButton, PrintDialog) :
  - 책임져야 할 행동이 있다면 스스로 요청을 처리하여 후속 처리자에 접근할 수 있음
  - 즉, 자신이 처리할 행동이 있으면 처리하고, 그렇지 않으면 후속 처리자에 다시 처리를 요청
- Client : ConcreteHandler 객체에게 필요한 요청을 보냄

## 협력 방법
- 사용자는 처리를 요청하고, 이 처리 요청은 실제로 그 요청을 받을 책임이 있는 ConcreteHandler 객체를 만날 때까지 정의된 연결 고리를 따라서 계속 전달됨

## 결과
- 책임 연쇄 패턴 장점
  - 1) 객체 간의 행동적 결합도가 적어짐
    - 다른 객체가 어떻게 요청 처리하는지 몰라도 되고, 단지 요청을 보내는 객체는 이 메시지가 적절하게 처리된 것이라는 것만 확신하면 됨
    - 메시지를 보내는 측이나 받는 측 모두 서로를 모르고, 또 연결된 객체들조차도 그 연결 구조가 어떻게 되는지 모름
    - 결과적으로, 이 패턴은 객체들 간의 상호작용 과정을 단순화 시킴 (자신은 자신과 연결된 단 하나의 후보 객체만 알면 됨)
  - 2) 객체에게 책임을 할당하는 데 유연성을 높일 수 있음
    - 객체의 책임을 여러 객체에게 분산시킬 수 있으므로 런타임에 객체 연결 고리를 변경하거나 추가하여 책임을 변경하거나 확장할 수 있음

- 책임 연쇄 패턴 단점
  - 1) 메시지 수신이 보장되지 않음
    - 어떤 객체가 이 처리에 대한 수신을 담당한다는 것을 명시하지 않으므로 요청이 처리된다는 보장 없음
    - 객체들 간의 연결 고리가 잘 정의되지 않는경우, 요청은 처리되지 못한 채로 버려질 수 있음 

## 구현


## 예제코드

## 잘 알려진 사용예
- java try-catch

## 관련 패턴


## 참고
- https://k0102575.github.io/articles/2020-02/chain-of-responsibility-pattern







