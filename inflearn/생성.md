### 팩토리 메소드 패턴
- 구체적으로 어떤 인스턴스를 만들지는 서브 클래스가 정한다.

- BlackShip을 생산했다가 WhiteShip에 대한 주문이 들어 온다면?
  - 코드 내부에서 if/else 로 분기가 계속 생길것이다.
- 그러다가 여러 종류의 배가 추가된다면?
  - Concrete class에 담아두기 복잡해 진다

- 해결책은?
  - 추상화된 팩토리를 만든다.
  
- 구조
  - ![스크린샷 2021-12-13 오후 11 18 21](https://user-images.githubusercontent.com/7076334/145828781-985d2ec3-c7d5-457a-a204-e50a51309805.png)
  - 여기서는 인터페이스 default 메서드를 이용해서 기본 기능 구현 하고 변경되는 부분만 ConcreteCreator에서 구현 (템플릿 메서드)
  - 확장한 유연한 구조로 만들어 진다.

## Before

```
public class ShipFactory {

    public static Ship orderShip(String name, String email) {
        // validate
        if (name == null || name.isBlank()) {
            throw new IllegalArgumentException("배 이름을 지어주세요.");
        }
        if (email == null || email.isBlank()) {
            throw new IllegalArgumentException("연락처를 남겨주세요.");
        }

        prepareFor(name);

        Ship ship = new Ship();
        ship.setName(name);

        // Customizing for specific name
        if (name.equalsIgnoreCase("whiteship")) {
            ship.setLogo("\uD83D\uDEE5️");
        } else if (name.equalsIgnoreCase("blackship")) {
            ship.setLogo("⚓");
        }

        // coloring
        if (name.equalsIgnoreCase("whiteship")) {
            ship.setColor("whiteship");
        } else if (name.equalsIgnoreCase("blackship")) {
            ship.setColor("black");
        }

        // notify
        sendEmailTo(email, ship);

        return ship;
    }

    private static void prepareFor(String name) {
        System.out.println(name + " 만들 준비 중");
    }

    private static void sendEmailTo(String email, Ship ship) {
        System.out.println(ship.getName() + " 다 만들었습니다.");
    }

}


public class Ship {

    private String name;

    private String color;

    private String logo;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getColor() {
        return color;
    }

    public void setColor(String color) {
        this.color = color;
    }

    public String getLogo() {
        return logo;
    }

    public void setLogo(String logo) {
        this.logo = logo;
    }

    @Override
    public String toString() {
        return "Ship{" +
                "name='" + name + '\'' +
                ", color='" + color + '\'' +
                ", logo='" + logo + '\'' +
                '}';
    }
}

```
- 만약 새로운 제품이 추가 된다면? 요구사항에 따라서 제품(Ship)의 항목들이 변경될 수 있다.
  - OCP 위배 (변경에 닫혀 있지 않다.)


## After
```
/**
 * Creator
 */
public interface ShipFactory {

    default Ship orderShip(String name, String email) {
        validate(name, email);
        prepareFor(name);
        Ship ship = createShip();
        sendEmailTo(email, ship);
        return ship;
    }

    void sendEmailTo(String email, Ship ship);

    Ship createShip();

    private void validate(String name, String email) {
        if (name == null || name.isBlank()) {
            throw new IllegalArgumentException("배 이름을 지어주세요.");
        }
        if (email == null || email.isBlank()) {
            throw new IllegalArgumentException("연락처를 남겨주세요.");
        }
    }

    private void prepareFor(String name) {
        System.out.println(name + " 만들 준비 중");
    }
}


/**
 * ConcreateCreator
 */
public class WhiteshipFactory extends DefaultShipFactory {

    @Override
    public Ship createShip() {
        return new Whiteship();
    }
}


/**
 * Product
 */
public class Ship {

    private String name;

    private String color;

    private String logo;

    private Wheel wheel;

    private Anchor anchor;


/**
 * ConcreteProduct
 */
public class Whiteship extends Ship {

    public Whiteship() {
        setName("whiteship");
        setLogo("\uD83D\uDEE5️");
        setColor("white");
    }
}

/**
 * Clinet (의존성 주입)
 */
public class Client {

    public static void main(String[] args) {
        Client client = new Client();
        client.print(new WhiteshipFactory(), "whiteship", "keesun@mail.com");
        client.print(new BlackshipFactory(), "blackship", "keesun@mail.com");
    }

    // 이 코드는 인터페이스 기반으로 만들었기 때문에 변경되지 않는다.
    private void print(ShipFactory shipFactory, String name, String email) {
        System.out.println(shipFactory.orderShip(name, email));
    }
}
```
- Diagram
  - ![스크린샷 2021-12-13 오후 11 45 12](https://user-images.githubusercontent.com/7076334/145833014-8889a479-51a7-4e9b-b31c-f34cb5ef4cd2.png)


- BlackShip을 만든다면 WhiteShip은 변경되지 않기 때문에 변경에 닫혀있다. (OCP 만족)
- Clinet 코드는 변경되지 않았느냐?
  - 그래서 의존성 주입을 통해 해결
- java9 부터 interface에서 private method 사용 가능
- 계층 구조는 클래스-클래스, 인터페이스-클래스, 인터페이스-추상클래스-클래스 상관 없다.
  - 중요한건 **구체적인 팩토리** 안에서 **구체적인 제품**을 만들어 낸다. 


## 팩토리 메소드 패턴 복습
- 팩토리 메서드 패턴의 장점과 단점
  - 장점 : OCP를 적용해서 기존 코드를 건들지 않고 새로운 종류의 인스턴스 확장 가능. (Creator와 Product을 느슨하게 가져갔기 때문에 가능)
  - 단점 : 각자의 역할을 나누다 보니 처음보다 클래스 갯수 늘어남

- OCP 객체지향 원칙을 설명
  - 변경에 닫혀 있다는 것은 기존 코드를 바꾸지 않고 새로운 기능을 확장할 수 있는 객체지향 원칙
    - ex) WhiteShip, BlackShip 

## 사용 예

- Calendar
  - Simple Factory 패턴
  ```
  public class SimpleFactory {

      public Object createProduct(String name) {
          if (name.equals("whiteship")) {
              return new Whiteship();
          } else if (name.equals("blackship")) {
              return new Blackship();
          }

          throw new IllegalArgumentException();
      }
  }
  ```

- BeanFactory (Spring)
```
public class SpringBeanFactoryExample {

    public static void main(String[] args) {
        BeanFactory xmlFactory = new ClassPathXmlApplicationContext("config.xml");
        String hello = xmlFactory.getBean("hello", String.class);
        System.out.println(hello);

        BeanFactory javaFactory = new AnnotationConfigApplicationContext(Config.class);
        String hi = javaFactory.getBean("hello", String.class);
        System.out.println(hi);
    }
}

// Custom bean
@Configuration
public class Config {

    @Bean
    public String hello() {
        return "hello";
    }
}
```
  - BeanFactory (Creator)
  - ClassPathXmlApplicationContext, AnnotationConfigApplicationContext (ConcreteCreator)
  - getBean (Product)
  - Custom Bean (ConcreteProduct)



### 추상 팩토리 패턴
- 서로 관련있는 여러 객체를 만들어 주는 인터페이스
- 구체적으로 어떤 클래스의 인스턴스를 사용하는지 감출 수 있다.

- 구체적인 팩토리에서 구체적인 제품을 만드는 부분까지는 팩토리메서드와 비슷하지만, 초점이 팩토리를 사용하는 클라이언트에 있다.
- 클라이언트에서 사용하는 팩토리를 인터페이스 기반으로 사용할 수 있도록 도와 주는 패턴
- 팩토리 메서드 패턴에 클라이언트가 추가된 형태

- 구조
  - ![스크린샷 2021-12-14 오전 12 05 41](https://user-images.githubusercontent.com/7076334/145836538-75e93d7a-86aa-4218-949b-7fff2f9dd51d.png)


## Before
```
/**
 * Clinet
 */
public class WhiteshipFactory extends DefaultShipFactory {

    @Override
    public Ship createShip() {
        Ship ship = new Whiteship();
        ship.setAnchor(new WhiteAnchor());
        ship.setWheel(new WhiteWheel());
        return ship;
    }
}
```
- 바퀴와 닻을 변경하려면? 직접 변경해야 한다.


## After
```
/**
 * AbstractFactory
 */
public interface ShipPartsFactory {

    Anchor createAnchor();

    Wheel createWheel();

}

/**
 * Production
 */
public interface Anchor {
}

public interface Wheel {
}

/**
 * ConcreteFactory
 */
public class WhiteshipPartsFactory implements ShipPartsFactory {

    @Override
    public Anchor createAnchor() {
        return new WhiteAnchor();
    }

    @Override
    public Wheel createWheel() {
        return new WhiteWheel();
    }
}

/**
 * ConcreteProduction
 */
public class WhiteAnchor implements Anchor {
}

public class WhiteWheel implements Wheel {
}

/**
 * Client
 */
 
public class ShipInventory {

    public static void main(String[] args) {
        ShipFactory shipFactory = new WhiteshipFactory(new WhiteshipPartsFactory());
        Ship ship = shipFactory.createShip();
        System.out.println(ship.getAnchor().getClass());
        System.out.println(ship.getWheel().getClass());
    }
}

public class WhiteshipFactory extends DefaultShipFactory {

    private ShipPartsFactory shipPartsFactory;

    public WhiteshipFactory(ShipPartsFactory shipPartsFactory) {
        this.shipPartsFactory = shipPartsFactory;
    }

    @Override
    public Ship createShip() {
        Ship ship = new Whiteship();
        ship.setAnchor(shipPartsFactory.createAnchor());
        ship.setWheel(shipPartsFactory.createWheel());
        return ship;
    }
}


```
- WhiteShipFactory 는 변하지 않는다.
  - OCP의 원칙을 지키고 있음
- ShipPartsFactory에서 Anchor, Wheel에 대한 제품을 두개를 만들었기 때문에 SRP를 위반한것 아니냐?
  - 견해의 차이

## 장점과 단점
- 팩토리 메소드 패턴
  - 객체를 만드는 과정에 집중되어 있다.

- 추상 팩토리 패턴
  - 팩토리 메소드와 비슷하지만 보는관점을 사용하는 관점에서 보자
  - 팩토리를 통해서 추상화된 인터페이스만 클라이언트에서 사용할 수 있기 때문에 Concreate 클래스를 직접참조하지 않아도 된다.

- 팩토리 메소드 vs 추상 팩토리 패턴
  - 모양과 효과는 비슷하지만
    - 둘 다 구체적인 객체 생성 과정을 추상화한 인터페이스를 제공
  - 관점이 다르다.
    - 팩토리 메소드 패턴은 '팩토리를 구현하는 방법(inheritance)'에 초점을 둔다.
    - 추상 팩토리 패턴은 '팩토리를 사용하는 방법composition)'에 초점을 둔다.
  - 목적이 조금 다르다.
    - 팩토리 메소드 패턴은 구체적인 객체 생성 과정을 하위 또는 구체적인 클래스로 옮기는 것이 목적
    - 추상 팩토리 패턴은 관련있는 여러 객체를 구체적인 클래스에 의존하지 않고 만들 수 있게 해주는게 목적


## 사용 예
- DocumentBuilderFactory
- FactoryBean<T> (Spring)
  - 만드는 과정이 복잡할 경우 FactoryBean을 구현해서 사용
  -Factory에서 만들어 주는 오브젝트가 빈으로 등록
```
public class ShipFactory implements FactoryBean<Ship> {

    @Override
    public Ship getObject() throws Exception {
        Ship ship = new Whiteship();
        ship.setName("whiteship");
        return ship;
    }

    @Override
    public Class<?> getObjectType() {
        return Ship.class;
    }
}

public class FactoryBeanExample {
    public static void main(String[] args) {
        ApplicationContext applicationContext = new AnnotationConfigApplicationContext(FactoryBeanConfig.class);
        Ship bean = applicationContext.getBean(Ship.class);
        System.out.println(bean);
    }
}
  
```
- AbstractFactory : FactoryBean
- ConcreteFactory : ShipFactory
- Product : Ship 
- ConcreteProduct : Whiteship
- Client : 스프링 내부에서 감지해서 사용

- 프레임워크에 추상팩토리 패턴이 많이 사용된다.


### 빌더 패턴
