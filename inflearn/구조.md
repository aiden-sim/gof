## 어댑터 패턴
- 기존 코드를 클라이언트가 사용하는 인터페이스의 구현체로 바꿔주는 패턴

- 구조
  - ![스크린샷 2021-12-31 오전 10 45 25](https://user-images.githubusercontent.com/7076334/147798251-298fd3aa-fe3b-4f1a-8d87-377c0d079b40.png)
  - 클라이언트가 사용하는 인터페이스를 따르지 않는 기존 코드를 재사용할 수 있게 해준다.

### before
```
public interface UserDetailsService {

    UserDetails loadUser(String username);

}

public class AccountService {

    public Account findAccountByUsername(String username) {
        Account account = new Account();
        account.setName(username);
        account.setPassword(username);
        account.setEmail(username);
        return account;
    }
}

```
- 전혀 다른 두 Service
  - UserDetailsService (공통)
  - AccountService (Account 에서만 사용)

### after

```
/**
 * client
 */
public class LoginHandler {

    UserDetailsService userDetailsService;

    public LoginHandler(UserDetailsService userDetailsService) {
        this.userDetailsService = userDetailsService;
    }

    public String login(String username, String password) {
        UserDetails userDetails = userDetailsService.loadUser(username);
        if (userDetails.getPassword().equals(password)) {
            return userDetails.getUsername();
        } else {
            throw new IllegalArgumentException();
        }
    }
}

/**
 * target
 */
public interface UserDetails {
    String getUsername();
    
    String getPassword();
}

public interface UserDetailsService {
    UserDetails loadUser(String username);
}

/**
 * adaptee
 */
public class AccountService {

    public Account findAccountByUsername(String username) {
        Account account = new Account();
        account.setName(username);
        account.setPassword(username);
        account.setEmail(username);
        return account;
    }
}

/**
 * adapter
 */
public class AccountUserDetails implements UserDetails {

    private Account account;

    public AccountUserDetails(Account account) {
        this.account = account;
    }

    @Override
    public String getUsername() {
        return account.getName();
    }

    @Override
    public String getPassword() {
        return account.getPassword();
    }
}

/**
 * adapter
 */
public class AccountUserDetailsService implements UserDetailsService {

    private AccountService accountService;

    public AccountUserDetailsService(AccountService accountService) {
        this.accountService = accountService;
    }

    @Override
    public UserDetails loadUser(String username) {
        return new AccountUserDetails(accountService.findAccountByUsername(username));
    }
}

```
- 코드를 수정할 수 없을 때
  - 장점 : 기존의 코드를 건들 지 않았음
  - 단점 : 클래스 추가

```

public class Account implements UserDetails {
    private String name;

    private String password;

    @Override
    public String getUsername() {
        return name;
    }

    @Override
    public String getPassword() {
        return password;
    }
}

public class AccountService implements UserDetailsService {
    public Account findAccountByUsername(String username) {
        Account account = new Account();
        account.setName(username);
        account.setPassword(username);
        account.setEmail(username);
        return account;
    }

    @Override
    public UserDetails loadUser(String username) {
        return findAccountByUsername(username);
    }
}

```
- 코드를 수정할 수 있을 때
  - 장점 : 별도 클래스 생성 안해도 된다.
  - 단점 : 코드가 바뀐다

- 위 두개 방식에 따라 실용주의 vs 원칙주의

### 어댑터 패턴 특징
- 기존 코드를 클라이언트가 사용하는 인터페이스의 구현체로 바꿔주는 패턴
- 장점
  - 기존 코드를 변경하지 않고 원하는 인터페이스 구현체를 만들어 재사용할 수 있다. (OCP 원칙)
  - 기존 코드가 하던 일과 특정 인터페이스 구현체로 변환하는 작업을 각기 다른 클래스로 분리하여 관리할 수 있다. (SRP 원칙)

- 단점
  - 새 클래스가 생겨 복잡도가 증가할 수 있다. 경우에 따라서는 기존 코드가 해당 인터페이스를 구현하도록 수정하는 것이 좋은 선택이 될 수도 있다. (실용주의)


### 사용 사례

- 자바
  - java.util.Arrays#asList(T...)
    - 배열을 List로 변경 
  - java.util.Collections#list(Enumeration), java.util.Collections#enumeration()
    - Enumeration 인터페이스는 Collection 프레임워크 만들어지기 전, Iterator의 이전 버전 
  - java.io.InputStreamReader(InputStream)
  - java.io.OutputStreamWriter(OutputStream)
    - 데이터를 다른 형태로 변환
      - String -> InputStream
      - InputStream -> InputStreamReader
      - InputStreamReader -> BufferedReader

- 스프링
  - HandlerAdpter: 우리가 작성하는 다양한 형태의 핸들러 코드를 스프링 MVC가 실행할 수 있 는 형태로 변환해주는 어댑터용 인터페이스.
  ```
  public interface HandlerAdapter {
    boolean supports(Object var1);

    @Nullable
    ModelAndView handle(HttpServletRequest var1, HttpServletResponse var2, Object var3) throws Exception;

    long getLastModified(HttpServletRequest var1, Object var2);
  }
  ```
    - HttpServletRequest var1, HttpServletResponse var2를 통해 ModelAndView 반환
    - https://velog.io/@jihoson94/Spring-MVC-HandlerAdapter-%EB%B6%84%EC%84%9D%ED%95%98%EA%B8%B0


## 브릿지 패턴
- 추상적인 것과 구체적인 것을 분리하여 연결하는 패턴

- 구조
  - ![스크린샷 2021-12-31 오후 3 10 41](https://user-images.githubusercontent.com/7076334/147806667-121df65a-1fd6-43be-af4c-112e78747b09.png)

  - 하나의 계층 구조일 때 보다 각기 나누었을 때 독립적인 계층 구조로 발전 시킬 수 있다.
  - ex) 추상적/구체적, 동작/상태, 프론트/백엔드, GUI/API 성격이 상이한 것들을 분리


  - Client는 추상적인 부분만 참조
  - Abstraction : 상위 추상적인 로직
  - Refined Abstraction : 추상적인 개념들을 변형/확장
  - Implementation / Concrete Implementation : 구체적인 상태/액션 코드 등

### before
```
public interface Champion extends Skin {

    void move();

    void skillQ();

    void skillW();

    void skillE();

    void skillR();

}

public class KDA아리 implements Champion {

    @Override
    public void move() {
        System.out.println("KDA 아리 move");
    }

    @Override
    public void skillQ() {
        System.out.println("KDA 아리 Q");
    }

    @Override
    public void skillW() {
        System.out.println("KDA 아리 W");
    }

    @Override
    public void skillE() {
        System.out.println("KDA 아리 E");
    }

    @Override
    public void skillR() {
        System.out.println("KDA 아리 R");
    }

    @Override
    public String getName() {
        return null;
    }
}

public class PoolParty아리 implements Champion {

    @Override
    public void move() {
        System.out.println("PoolParty move");
    }

    @Override
    public void skillQ() {
        System.out.println("PoolParty Q");
    }

    @Override
    public void skillW() {
        System.out.println("PoolParty W");
    }

    @Override
    public void skillE() {
        System.out.println("PoolParty E");
    }

    @Override
    public void skillR() {
        System.out.println("PoolParty R");
    }

    @Override
    public String getName() {
        return null;
    }
}

public static void main(String[] args) {
    Champion kda아리 = new KDA아리();
    kda아리.skillQ();
    kda아리.skillR();
}
    
```
- 계층 구조가 커짐
- 중복 코드 발생

### after
```

/**
 * Abstraction
 */
public interface Champion extends Skin {
    void move();

    void skillQ();
}
 
public class DefaultChampion implements Champion {

    private Skin skin;

    private String name;

    public DefaultChampion(Skin skin, String name) {
        this.skin = skin;
        this.name = name;
    }

    @Override
    public void move() {
        System.out.printf("%s %s move\n", skin.getName(), this.name);
    }

    @Override
    public void skillQ() {
        System.out.printf("%s %s Q\n", skin.getName(), this.name);
    }

    @Override
    public String getName() {
        return null;
    }
}

/**
 * Refined Abstraction
 */
public class 아리 extends DefaultChampion {
    public 아리(Skin skin) {
        super(skin, "아리");
    }
}

public class 아칼리 extends DefaultChampion{
    public 아칼리(Skin skin) {
        super(skin, "아칼리");
    }
}

/**
 * Implementation
 */
public interface Skin {
    String getName();
}

/**
 *  Concrete Implementation
 */
public class KDA implements Skin {
    @Override
    public String getName() {
        return "KDA";
    }
}

public class PoolParty implements Skin {
    @Override
    public String getName() {
        return "PoolParty";
    }
}

/**
 *  Client
 */
public abstract class App implements Champion {

    public static void main(String[] args) {
        Champion kda아리 = new 아리(new KDA());
        kda아리.skillQ();
        kda아리.skillW();

        Champion poolParty아리 = new 아리(new PoolParty());
        poolParty아리.skillR();
        poolParty아리.skillW();
    }
}
```
- Client 코드가 implmention(KDA)를 참조하고 있다고 생각할 수 있지만 의존 주입등의 방식으로 변경한다면 Client 코드는 Champion만 사용될 수 있다.




## 컴포짓 패턴

