# 서론
- 객체지향 소프트웨어 설계의 어려움
  - 설계는 지금 당장 갖고 있는 문제를 해결할 수 있어야 하지만, 나중에 생길 수 있는 문제나 추가된 요구 사항들도 수용할 수 있도록 일반적이로 포괄적이어야 함

- 경험자들이 좋은 객체지향을 설계할 수 있는 이유
   - 기초 단계에서 해결하지 않고, 전에 사용했던 해결책을 다시 사용해봄으로써 좋은 방법을 찾았다면 그 방법을 반복해서 계속 사용하게 됨
   - 반복된 패턴들은 특정 설계의 문제점들을 해결해 주고, 좀더 유연하고, 근사하며, 재사용 가능한 객체지향 소프트웨어를 만들어 줌

- 이 책의 목적
  - '디자인 패턴'이란 방식을 통해 소프트웨어 설계에서 얻은 세세한 경험들을 기록해 놓도록 하는 것

- 디자인 패턴
  - 디자인 패턴을 이용하면 좋은 설계나 아키텍처를 재사용하기 쉬워짐
  - 이미 만든 시스템의 유지보수나 문서화도 개선할 수 있고, 클래스의 명세도 정확하게 할 수 있으며, 객체 간의 상호작용 또는 설계의 의도 등까지 명확하게 정의
  - 디자인 패턴은 설계자들이 '올바른' 설계를 빨리 만들 수 있도록 도와줌

# 1.1 디자인 패턴이란?
- 패턴의 네 가지 요소
  - 1) 패턴 이름
    - 패턴의 이름을 정의해 두면 문서에서 이 이름을 사용하여 설계의 의도를 표현할 수 있게 됨
    - 이름을 갖게 되면 설계에 대한 생각을 더욱 쉽게 할 수 있고, 개발자들 간의 의사소통이 원활해짐
  - 2) 문제
    - 언제 패턴을 사용하는가를 서술하며 해결할 문제와 그 배경을 설명
  - 3) 해법
    - 설계를 구성하는 요소들과 그 요소들 간의 관계, 책임 그리고 협력 관계를 서술
    - 구체적인 부분 대신, 문제에 대한 추상적인 설명을 제공하고 문제를 해결하기 위해서 클래스나 객체들의 나열 방법을 제공
  - 4) 결과
    - 디자인 패턴을 적용해서 얻는 결과와 장단점을 서술
    - 선택하는 과정에서 또는 비용과 효과를 측정하는 과정에서 설계의 결과는 가장 중요한 부분
    - 재사용은 객체지향 설계의 주요 요소이므로, 패턴의 결과는 시스템의 유연성, 확장성, 이식성등에 커다란 영향을 줌

- 디자인 패턴은 '특정한 전후 관계에서 일반적 설계 문제를 해결하기 위해 상호교류하는 수정 가능한 객체와 클래스들에 대한 설명'

- 이 책에서는?
  - 하나의 디자인 패턴은 재사용 가능한 객체지향 설계를 만들기 위해 유용한 공통의 설계 구조에서 주요 요소들을 식별하여 이들에게 적당한 이름을 주고 추상화 함
  - 패턴에 참여하는 클래스와 그들의 인스턴스를 식별하여 역할과 그들 간의 협력 관계를 정의하고 책임을 할당함 
  - 각 디자인 패턴은 각자 맡은 객체지향 설계 문제에 집중
  - 언제 패턴을 적용할지, 다른 설계 제약을 고려하여 패턴을 적용할 수 있는지, 패턴을 사용하면 어떤 결과가 발생하는지 설명


# 1.2 스몰토크 MVC를 사용한 디자인 패턴
- MVC
  - 모델(Model) : 응용프로그램 객체
  - 뷰(View) : 스크린에 모델을 디스플레이하는 방법을 정의
  - 컨트롤러(Controller) : 사용자 인터페이스가 사용자 입력에 반응하는 방법을 정의
    - MVC 사용전에는 이러한 객체들을 모두 묶어서 하나의 객체로 처리했었음...

- MVC는 뷰와 모델 간에 등록/통지 프로토콜을 만들어 종속성을 없앤다
  - 뷰는 그 외형이 반드시 모델의 상태를 반영하도록 보장

- 감시자 패턴
  - MVC 예시에서 모델은 값이 변할 때마다 뷰에게 알려주고, 뷰들은 값을 표현하고 조작하기 위해 모델과 교류
  - 한 객체에서 일어난 변경을 다른 객체들에 반영하도록 별도의 객체를 둠으로써, 변경이 일어난 객체는 변경 반영이 필요한 다른 객체들을 알 필요가 없게끔 객체를 분리

- 복합체 패턴
  - MVC의 특징으로 뷰를 중첩시킬 수 있음
  - 복합 뷰 객체(자식)는 일반 뷰(부모) 객체가 사용되는 곳이면 동일하게 사용될 수 있음
  - 단일 객체처럼 복합 객체를 사용하고 싶을 때 사용

- 전략 패턴
  - MVC 시각적 표현 방법의 변경 없이 사용자 입력에 대한 뷰의 반응 방법을 변경할 수 있음
  - 특정 대응 전략을 구현하기 위해 View 클래스가 Controller 서브클래스의 인스턴스를 사용한다면, 다른 전략을 구현하기 위해 현재의 컨트롤러 인스턴스를 다른 종류의 컨트롤러 인스턴스로 대체만 하면 됨
  - 전략 패턴은 알고리즘을 표현하는 객체로 정적 또는 동적으로 알고리즘을 대체하고자 할 때 매우 유용한 방식

# 1.3 디자인패턴 기술하기
- 설계를 재사용하기 좋게 만들려면 설계를 하기까지의 다양한 결정, 대안, 장단점 등을 고려한 과정도 함께 적어주어야 함
- 각각의 패턴은 다음 템플릿에 따라서 구분하여 정의
- 템플릿은 디자인 패턴을 배우고 비교하며, 더 쉽게 사용할 수 있도록 일관된 구조를 제공

## 패턴 이름과 분류
- 하나의 패턴에 붙은 이름은 그 자체가 핵심을 간결하게 전달해줌

## 의도
- '이 디자인 패턴은 무엇을 하는것일까요? 의도와 논리적인 근거가 무엇일까요? 어떤 특정한 문제나 이슈를 해결하기 위한 것일까요?' 에 대한 간결한 답을 제시

## 다른 이름
- 이 패턴을 다르게 부르는 이름이 있다면, 그것을 제시

## 동기
- 설계 문제를 제시하고, 패턴 안에서 클래스나 객체 구조가 어떻게 문제를 해결하는지 설명해 주는 일종의 시나리오
- 이 시나리오는 패턴에 대한 좀더 추상화된 설명을 이해할 수 있게 도와줌

## 활용성
- '해당 패턴을 어떤 상황에 적용할 수 있을까요? 패턴이 문제로 삼는 잘못된 설계의 예는 무엇일까요? 이 상황을 어떻게 팡가할 수 있을까요?'

## 구조
- 객체 모델링 기법에 기반을 둔 표기법을 이용하여 해당 패턴에서 쓰는 클래스들을 시각적으로 나타냄
- 객체 사이에 오가는 요청과 협력 관계의 순차를 표현하기 위해서 상호작용 다이어그램도 이용

## 참여자
- 주어진 패턴을 구성하고 책임을 수행하는 클래스나 객체들을 설명

## 협력 방법
- 참여자들이 작업을 수행하기 위한 참여자들 간의 협력 관계를 정의

## 결과
- '이 패턴이 자신의 목표를 어떻게 지원할까요? 이 패턴을 이용한 결과는 무엇인고 장단점은 무엇일까요? 이 패턴을 사용하면 시스템 구조의 어떤 면을 독립적으로 다양화시킬 수 있을까요?'

## 구현
- '패턴을 구현할 때 주의해야 할 함정, 힌트, 기법 등은 무엇일까요? 특정 언어에 국한된 특이 사항은 무엇일까요?'

## 예제 코드
- C++나 스몰토크를 이용한 예제 코드

## 잘 알려진 사용예
- 실제 시스템에서 찾아볼 수 있는 패턴들의 예

## 관련 패턴
- '이 패턴과 밀접하게 관련된 다른 패턴들은 무엇일까요? 이들의 중요한 차이점은 무엇일까요? 어떤 다른 패턴에 이 패턴이 사용되어야 할까요?'

# 1.4 디자인 패턴 카탈로그
- 23개의 디자인 패턴

## Abstract Factory
- 구체적인 클래스를 지정하지 않고 관련성을 갖는 객체들의 집합을 생성하거나 서로 독립적인 객체들의 집합을 생성할 수 있는 인터페이스를 제공하는 패턴

## Adapter
- 클래스의 인터페이스를 사용자가 기대하는 다른 인터페이스로 변환하는 패턴으로, 호환성이 없는 인터페이스 때문에 함께 동작할 수 없는 클래스들이 함께 작동하도록 해 줌

## Bridge
- 구현부에서 추상층을 분리하여 각자 독립적으로 변형할 수 있게 하는 패턴

## Builder
- 복합 객체의 생성 과정과 표현 방법을 분리하여 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있게 하는 패턴

## Chain of Responsibility
- 요청을 처리할 수 있는 기회를 하나 이상의 객체에게 부여하여 요청을 보내는 객체와 그 요청을 받는 개체 사이의 결합을 피하는 패턴
- 요청을 받을 수 있는 객체를 연쇄적으로 묶고, 실제 요청을 처리할 객체를 만날 때까지 객체 고리를 따라 요청을 전달

## Command
- 요청을 객체의 형태로 캡슐화하여, 서로 요청이 다른 사용자의 매개변수화, 요청 저장 또는 로깅, 그리고 연산의 취소를 지원하게 만드는 패턴

## Composite
- 객체들의 관계를 트리 구조로 구성하여 부분-전체 계층을 표현하는 패턴으로, 사용자가 단일 객체와 복합 객체 모두 동일하게 다루도록 함

## Decorator
- 주어진 상황 및 용도에 따라 어떤 객체에 책임을 덧붙이는 패턴으로, 기능 확장이 필요할 때 서브클래싱 대신 쓸 수 있는 유연한 대안이 될 수 있음

## Facade
- 서브시스템에 있는 인터페이스 집합에 대해서 하나의 통합된 인터페이스를 제공하는 패턴으로, 서브시스템을 좀더 사용하기 편하게 만드는 상위 수준의 인터페이스를 정의

## Factory Method
- 객체를 생성하는 인터페이스는 미리 정의하되, 인스턴스를 만들 클래스의 결정은 서브클래스 쪽에서 내리는 패턴
- 팩토리 메서드 패턴에서는 클래스의 인스턴스를 만드는 시점을 서브클래스로 미룸

## Flyweight
- 크기가 작은 객체가 여러 개 있을 때, 공유를 통해 이들을 효율적으로 지원하는 패턴

## Interpreter
- 주어진 언어에 대해, 그 언어의 문법을 위한 표현 수단을 정의하고, 이와 아울러 그 표현 수단을 사용하여 해당 언어로 작성된 문장을 해석하는 해석기를 정의하는 패턴

## Iterator
- 내부 표현부를 노출하지 않고 어떤 객체 집합에 속한 원소들을 순차적으로 접근할 수 있는 방법을 제공하는 패턴

## Mediator
- 한 집합에 속해있는 객체들의 상호작용을 캡슐화하는 객체를 정의한는 패턴
- 객체들이 직접 서로를 참조하지 않도록 함으로써 객체들 사이의 소결합(loose coupling)을 촉진시키며, 개발자가 객체들의 상호작용을 독립적으로 다양화시킬 수 있게 만듬

## Memento
- 캡슐화를 위배하지 않은 채 어떤 객체의 내부 상태를 잡아내고 실체화시켜, 이후에 해당 객체가 그 상태로 다시 되돌아올 수 있도록 하는 패턴

## Observer
- 객체 사이에 일 대 다의 의존 관계를 정의해 두어, 어떤 객체의 상태가 변할 때 그 객체에 의존성을 가진 다른 객체들이 그 변화를 통지받고 자동으로 갱신될 수 있게 만드는 패턴

## Prototype
- 생성할 객체의 종류를 명세화하는 데에 원형이 되는 예시물을 이용하고, 그 원형을 복사함으로써 새로운 객체를 생성하는 패턴

## Proxy
- 어떤 다른 객체로 접근하는 것을 통제하기 위해서 그 객체의 대리자 또는 자리채움자를 제공하는 패턴

## Singleton
- 어떤 클래스의 인스턴스는 오직 하나임을 보장하며, 이 인스턴스에 접근할 수 있는 전역적인 접촉점을 제공하는 패턴

## State
- 객체의 내부 상태에 따라 스스로 행동을 변경할 수 있게끔 허가하는 패턴으로, 이렇게 하면 객체는 마치 자신의 클래스를 바꾸는 것처럼 보임

## Strategy
- 동일 계열의 알고리즘군을 정의하고 각각의 알고리즘을 캡슐화하며, 이들을 상호교환이 가능하도록 만드는 패턴
- 알고리즘을 사용하는 사용자와 상관없이 독립적으로 알고리즘을 다양하게 변경할 수 있게 함

## Template Method
- 객체의 연산에는 알고리즘의 뼈대만을 정의하고 각 단계에서 수행할 구체적 처리는 서브클래스 쪽으로 미루는 패턴
- 알고리즘의 구조 자체는 그대로 놔둔 채 알고리즘 각 단계의 처리를 서브클래스에서 정의할 수 있게 함

## Visitor
- 객체 구조를 이루는 원소에 대해 수행할 연산을 표현하는 패턴으로, 연산을 적용할 원소의 클래스를 변경하지 않고도 새로운 연상을 정의할 수 있게 함

# 1.5 카탈로그 조직화하기
![pattern](https://user-images.githubusercontent.com/7076334/128636419-ddd6914f-cf11-4e89-a848-10572520ac27.png)

- 패턴 분류 기준
  - 1) 목적
    - 패턴은 생성, 구조, 행동 중의 한 가지 목적을 갖음
    - 생성 패턴은 객체의 생성 과정에 관여
    - 구조 패턴은 클래스나 객체의 합성에 관한 패턴
    - 행동 패턴은 클래스나 객체들이 상호작용하는 방법과 책임을 분사하는 방법을 정의
  - 2) 범위
    - 패턴을 주로 클래스에 적용하는지 아니면 객체에 적용하는지를 구분하는 것
    - 클래스 패턴은 클래스와 서브클래스 간의 관련성을 다루는 패턴 (주로 상속이며, 컴파일 타임에 정적으로 결정)
    - 객체 패턴은 객체 관려성을 다루는 패턴 (런타임에 변경할 수 있으며 동적인 성격을 가짐)

- 목적과 범위 결합
  - 생성 클래스 패턴 : 생성하는 책임의 일부를 서브클래스가 담당하도록 넘김
  - 생성 객체 패턴 : 생성하는 책임을 다른 객체에게 위임
  - 구조 클래스 패턴 : 상속을 이용해서 클래스를 복합함
  - 구조 객체 패턴 : 객체를 합성하는 방법을 정의
  - 행동 클래스 패턴 : 상속을 이용해서 알고리즘과 제어 흐름을 기술
  - 행동 객체 패턴 : 하나의 작업을 수행하기 위해 객체 집합이 어떻게 협력하는지를 기술

- 패턴을 조직하는 또 다른 방법
  - 일부 패턴은 함께 사용 됨 
    - ex) 복합체 패턴은 반복자 패턴과 방문자 패턴을 함께 사용하는 경우도 있음
  - 어떤 패턴은 다른 패턴의 대안 
    - ex) 원형 패턴은 추상 팩토리 패턴의 대안
  - 패턴 간의 의도는 서로 다르지만 결과적으로 유사한 설계 구조를 만드는 패턴 
    - ex) 복합체 패턴과 장식자 패턴의 의도는 다르지만 구조는 비슷

- 패턴 간의 참조 관계에 따라 관리하는 방법

![pattern2](https://user-images.githubusercontent.com/7076334/128636756-0577b716-f08f-4fd2-a5c5-499b69459a8b.png)


# 1.6 디자인 패턴을 이용하여 문제를 푸는 방법
- 디자인 패턴은 객체지향 설계자들이 매일 부딪히게 되는 많은 문제를 다양한 방법으로 해결해 줌

## 적당한 객체 찾기
- 용어 정리
  - 객체지향 프로그램은 **객체**(object)로 만듬
  - 객체는 데이터와 이 데이터에 연산을 가하는 **프로시저**(procedure)를 함께 묶은 단위
  - 프로시저를 일반적으로 **메서드** (method) 또는 **연산**(operation) 이라고 함
  - 객체는 **요청**(request) 또는 **메시지**(message)를 사용자에게 받으면 연산을 수행함

- 요청과 연산
  - 요청은 객체가 연산을 실행하게 하는 유일한 방법
  - 연산은 객체의 내부 데이터의 상태를 변경하는 유일한 방법
    - 이러한 접근의 제약 사항으로 객체의 내부 상태는 캡슐화 된다고 말함
    - 객체 외부에서는 객체의 내부 데이터에 직접 접근할 수 없고, 객체 내부 데이터 표현 방법(데이터 타입 등)을 알 수 없음 

- 객체의 분할
  - 객체지향 설계의 가장 어려운 부분은 시스템을 구성할 객체의 분할을 결정하는 것
  - 고려 요인에는 캡슐화, 크기 정하기, 종속성, 유연성, 성능, 진화, 재사용성등이 있음

- 객체 분할에 대한 객체지향 설계 방법론들의 접근
  - 문제 기술서를 작성하고 명사와 동사를 추출해서 각각을 클래스와 연산으로 만드는 방법 (command, query)
  - 시스템의 협력 관계나 책임성을 중심으로 설계하는 방법 (DDD)
  - 실세계를 모델로 만들고 이를 분석해 설계로 전이하는 과정에서 객체로 바꾸는 방법
    - 어떤방법이 가장 좋타 얘기할 수 없음

- 객체지향 설계와 실세계 대응의 한계
  - 분석 모델의 객체는 실세계 객체들이지만, 설계 모델의 객체에는 배열, 리스트처럼 구현에 가까운 클래스들도 있음
  - 어떤 설계 클래스들은 높은 수준의 추상화를 보일 수도 있음
    - ex) 복합체 패턴 : 분석 모델과 물리적 대응 관계를 갖지는 않지만, 객체들을 동일하게 다루게 해주는 추상적 개념
  - 실세계를 그대로 반영하는 모델링만 강조하면 현재는 반영할 수 있지만 미래의 실세계는 반영할 수 없음 (유연성이 떨어짐)
  
- 디자인 패턴은 덜 명확한 추상적 개념(유연한 설계를 위해 반드시 필요)과 이것을 잡아낸 객체를 알아보는데 도움을 준다.
  - 전략 패턴은 상호교환이 가능한 알고리즘을 어떻게 구현할지 설명
  - 상태 패턴은 대상들의 각 상태를 객체로 표현

## 객체의 크기 결정
- 적당한 객체의 규모는 어떻게 결정할까?
  - Facade : 서브시스템을 어떻게 객체로 표현할 수 있을지 설명
  - Flyweight : 작지만 개수는 많은 객체를 다루는 방법 (Intger -128 ~ 127 caching)
  - Abstract Factory Method / Builder : 다른 객체를 생성하는 책임만 있는 객체를 만들어 냄
  - Visitor / Command : 요청을 자신이 처리하는 것이 아닌, 다른 객체나 객체 집합이 요청을 처리하여 구현하도록 책임지는 객체를 만들어냄


## 객체 인터페이스의 명세
- 용어 정리
  - 시그너처(signature)
    - 객체가 선언하는 모든 연산은 연산의 이름, 매개변수로 받아들이는 객체들, 연산의 반환 값을 명세
  - 인터페이스(interface)
    - 객체가 정의하는 연산의 모든 시그너처들을 일컫는 말로 객체의 인터페이스는 객체가 받아서 처리할 수 있는 연산의 집합
    - 객체 인터페이스에 정의된 시그너처와 일치하는 어떤 요청이 객체에 전달되면, 객체는 연산을 수행하여 그 요청을 처리
  - 타입(type)
    - 특정 인터페이스를 나타낼 때 사용하는 이름 (위에서 말하는 인터페이스와 개념이 같나?)
    - 서브타입(subtype)은 다른 인터페이스를 포함하는 인터페이스
      - 서브타입은 슈퍼타입의 인터페이스를 상속함
      - 상속하면 서브타입은 슈퍼타입에 정의된 연산을 포함 
    - 슈퍼타입(supertype)은 다른 인터페이스가 포함하는 인터페이스

- 인터페이스 개념
  - 객체는 인터페이스로 자신을 드러냄
  - 외부에서는 인터페이스를 통해서만 처리를 요청할 수 있음
  - 객체의 인터페이스는 구현에 대해서는 전혀 알려주지 않음
  - 서로 다른 객체는 인터페이스에 정의한 요청의 구현 방법을 자유롭게 선택할 수 있음 (다형성으로 이해함)

- 동적 바인딩
  - 객체에 요청이 전달되면, 요청과 이를 받는 객체에 따라서 수행되는 처리 방식이 달라짐
    - 객체가 실제 어떻게 구현을 했는가에 따라 다른 결과가 나올 수 있음
  - 어떤 요청과 그 요청을 처리할 객체를 프로그램 실행 중, 즉 런타임에 연결 짓는 것을 **동적 바인딩**(dynamic binding) 이라고 함

- 다형성
  - 동적 바인딩은 프로그램이 기대하는 객체를 동일한 인터페이스를 갖는 다른 객체로 대체할 수 있게 해줌
  - 이를 다형성이라고 하는데, 객체지향 시스템의 핵심 개념
  - 다형성은 사용자의 정의를 단순화하고 객체 간의 결합도를 없애며, 프로그램 실행 중에는 서로 간의 관련성을 다양화할 수 있게 해줌

- 디자인 패턴과 인터페이스의 관계
  - 디자인 패턴은 인터페이스에 정의해야 하는 중요 요소가 무엇이고 어떤 종류의 데이터를 주고받아야 하는지 식별하여 인터페이스를 정의하도록 도와 줌
    - ex) 메멘토 : 상태를 저장하고 복사할 수 있는 인터페이스, 원본 객체가 그 메멘토에서 상태를 저장하고 검색하기 위해 사용하는 인터페이스 정의 
  - 가끔 인터페이스에 넣지 말아야 할 것을 알려주기도 함
  - 인터페이스 간의 관련성도 정의
    - 클래스 간에 유사한 인터페이스를 정의하거나 하거나 클래스의 인터페이스에 여러 가지 제약을 정의 
    - ex) 프록시패턴: 프록시 객체의 인터페이스는 자신이 대리하는 다른 객체의 인터페이스와 동일 (실제 real 객체에 접근을 제약하기도 함)

## 객체 구현 명세하기
- 클래스 정의 (OMT 표기법)
  - ![스크린샷 2021-08-09 오전 1 26 21](https://user-images.githubusercontent.com/7076334/128638863-f04dcad5-bef8-4f7c-886f-b3dafe63b5a5.png) 
    - 클래스는 객체의 내부 데이터와 표현 방법을 명세하고, 그 객체가 수행할 연산을 정의
    - 연산의 이름은 클래스 이름 아래줄에 나열, 클래스가 정의하는 데이터는 연산 아래 줄에 표시
    - 클래스 이름과 연산 이름, 연산과 데이터는 선으로 구분
    - 연산의 반환 타입과 인스턴스 변수 타입의 정의는 선택 사항

- 클래스, 객체, 인스턴스
  - ![스크린샷 2021-08-09 오전 1 26 40](https://user-images.githubusercontent.com/7076334/128638979-cbbc1139-70f6-479d-9590-45c21e8ec902.png)
    - 객체는 클래스의 인스턴스
    - 클래스의 인스턴스화 과정은 객체의 내부 데이터[인스턴스 변수]에 대한 공간을 할당하고, 이 데이터들을 연산과 관련짓는 것
    - 클래스의 인스턴스화 과정을 통해 객체의 인스턴스를 얻게 된다.
    - 점선 화살표는 한 클래스(instantiator)가 다른 클래스(instantiatee)의 객체를 인스턴스화함을 의미
      - 화살표의 방향은 생성할 객체의 클래스로 향함
  - 예제
    ```
    /* 클래스 */
    public class Animal {
      ...
    }

    /* 객체와 인스턴스 */
    public class Main {
      public static void main(String[] args) {
        Animal cat, dog; // '객체'

        // 인스턴스화
        cat = new Animal(); // cat은 Animal 클래스의 '인스턴스'(객체를 메모리에 할당)
        dog = new Animal(); // dog은 Animal 클래스의 '인스턴스'(객체를 메모리에 할당)
      }
    }
    ```

- 부모클래스, 서브클래스
  - ![스크린샷 2021-08-09 오전 1 27 04](https://user-images.githubusercontent.com/7076334/128639513-ae18622d-014e-4d47-bf7d-7d9556250490.png)
    - 새로운 클래스는 기존 클래스에 기반을 둔 클래스 상속을 사용하여 정의할 수 있음
    - 서브클래스가 부모 클래스를 상속하면, 부모 클래스가 갖는 모든 데이터와 연산을 서브클래스가 갖게됨
    - 서브클레스 관계는 수직선과 삼각형을 써서 나타냄 (상속은 실선, 구현은 점선)
      - 삼각형 밑변이 서브클래스, 꼭지점이 부모 클래스

- 추상 클래스
  - ![스크린샷 2021-08-09 오전 1 27 30](https://user-images.githubusercontent.com/7076334/128639624-a5e980f9-84e4-42fe-8353-9aa3a3508ace.png)
    - 추상 클래스는 모든 서브클래스 사이의 공통되는 인터페이스를 정의
    - 정의한 연산 모두가 추상 클래스로 구현된 것이 아니므로, 추상 클래스는 인스턴스 생성 불가
    - 정의만 하고 구현하지 않는 연산을 **추상 연산** 이라고 함
    - 추상 클래스가 아닌 클래스를 구체 클래스라고 함
    - 서브클래스는 **오버라이드**를 통해 부모 클래스에 정의된 처리 방식을 변경할 수 있음
    - 추상 클래스의 이름은 이탤릭체로 표기하여 다른 클래스와 구분 (추상 연산도 이탤릭체)
    - 구현에 대한 사항을 모서리가 접힌 **노트 기호**에 작성하고 연산과 실선으로 연결하면 됨

- 믹스인 클래스
  - ![스크린샷 2021-08-09 오전 1 28 25](https://user-images.githubusercontent.com/7076334/128639751-dbe2a6e5-ae0b-49ec-b71b-2cdf86ae3ecd.png)
    - 다른 클래스들에게 선택적인 인터페이스 혹은 기능을 제공하려는 목적을 가진 클래스
    - 인스턴스로 만들 의도가 없다는 면에서 추상클래스와 비슷 (자바에서 다중상속이 가능한 인터페이스로 구현)

### 클래스 상속 대 인터페이스 상속
- 클래스와 타입(인터페이스) 사이의 차이!
- 객체의 클래스는 그 객체가 어떻게 구현되느냐를 정의
  - 클래스는 객체의 내부 상태와 그 객체의 연산에 대한 구현 방법을 정의
- 반면 객체의 타입은 그 객체의 인터페이스, 즉 그 객체가 응답할 수 있는 요청의 집합을 정의
- 하나의 객체가 여러 타입을 가질 수 있고 서로 다른 클래스의 객체들이 동일한 타입을 가질 수 있음 (인터페이스)
  - 객체의 구현은 다를지라도 인터페이스는 같을 수 있음

- 클래스 상속과 인터페이스(서브타이핑) 상속 차이
  - 상속
    - 상속은 객체의 구현을 정의할 때 이미 정의된 객체의 구현을 바탕으로 함
    - 쉬게 말해 코드와 내부 표현 구조를 공유하는 메커니즘
  - 인터페이스 상속(서브타이핑)
    - 어떤 객체가 다른 객체 대신에 사용될 수 있는 경우를 지정하는 메커니즘 (런타임에 서브타입의 객체로 대체 가능)

- 추상 클래스를 상속한다는 것은 단순한 코드의 재사용을 위한 상속이 아니라 추상 클래스가 정의하는 인터페이스를 상속하겠다는 의미 (

### 구현에 따르지 않고, 인터페이스에 따르는 프로그래밍
- 상속의 기능
  - 클래스 상속은 기본적으로 부모 클래스에서 정의한 구현을 재사용하여 응용프로그램의 기능성을 확장하려는 메커니즘
  - 동일한 인터페이스를 갖는 객체군을 정의하는 것 (재사용성이 다가 아님)
    - 다형성을 끌어낼 수 있기 때문에 중요함

- 추상 클래스를 정의하고 인터페이스 개념으로 객체를 다룰 때 얻는 두 가지 이점
  - 1) 사용자가 원하는 인터페이스를 그 객체가 만족하고 있는 한, 사용자는 그들이 사용하는 특정 객체 타입에 대해 알아야할 필요가 없음
  - 2) 사용자는 이 객체들을 구현하는 클래스를 알 필요가 없고, 단지 인터페이스를 정의하는 추상 클래스가 무엇인지만 알면 됨
    - 이렇게 하면 서스시스템 간의 구현 종속성이 없어짐

- 어떤 변수(객체)를 구체 클래스의 인스턴스로 선언하는 일은 피하자. 대신 추상 클래스의 인터페이스를 따르는 인스턴스 변수를 정의

## 재사용을 실현 가능한 것으로
 
### 상속 대 합성
- 클래스 상속
  - 서브클래싱, 즉 다른 부모 클래스에서 상속받아 한 클래스의 구현을 정의하는 것
  - 화이트박스 재사용이라고 함 (상속을 받으면 부모 클래스의 내부가 서브클래스에 공개되기 때문에)

- 객체 합성
  - 클래스 상속에 대한 대안
  - 다른 객체를 여러 개 붙여서 새로운 기능 혹은 객체를 구성하는 것 (믹스인?)
  - 블랙박스 재사용이라고 함 (객체의 내부는 공개되지 않고 인터페이스를 통해서만 재사용되기 때문에)

- 클래스 상속의 장단점
  - 장점
    - 컴파일 시점에 정적으로 정의되고 프로그래밍 언어가 직접 지원하므로 그대로 사용하면 됨 (이해하는데 직관적임)
    - 서브클래스에서 모든 연산이 아닌 일부만 재정의할 수도 있음  
  - 단점
    - 런타임에 상속받은 부모 클래스의 구현을 변경할 수 없음 (상속은 컴파일 시점에 결정됨)
    - 서브클래스는 부모 클래스가 정의한 물리적 표현들을 전부 또는 일부 상속받는다는 점 (캡슐화 파괴)
    - 서브클래스는 부모 클래스의 구현에 종속될 수밖에 없으므로, 부모 클래스 구현에 변경이 생기면 서브클래스도 변경해야됨
      - 이런 종속성은 유연성과 재사용성을 떨어뜨림

- 객체 합성
  - 객체 합성은 한 객체가 다른 객체에 대한 참조자를 얻는 방식으로 런타임에 동적으로 정의
  - 객체는 인터페이스에서만 접근하므로 캡슐화를 유지할 수 있음
  - 객체는 인터페이스에 맞춰 구현되므로 구현 사이의 종속성이 확실히 줄어듬
  - 객체 합성은 각 클래스의 캡슐화를 유지할 수 있고, 각 클래스의 한 가지 작업에 집중할 수 있음

- 클래스 합성보다 객체 합성
  - 합성을 사용하면 기존의 구성요소를 조립해서 모든 새로운 기능을 얻어올 수 있음
    - 그러나 구성요소 집합이 실제로 사용할 수 있을 만큼 충분하지 않기 때문에, 기존 구성요소의 조합을 통한 재사용만으로 목적 달성 힘듬
  - 상속에 의한 재사용은 기존 클래스들을 조합해서 새로운 구성요소를 쉽게 만들 수 있게 해줌
    - 그러나 상속과 객체 합성은 적절히 조합되어야 완벽한 재사용이 가능함

- 합성은 구현에 의존하지 않고 퍼블릭 인터페이스만 의존한다. (캡슐화가 지켜짐)

### 위임
- 위임이란?
  - 위임(delegation) 은 합성을 상속만큼 강력하게 만드는 방법
  - 수신 객체가 연산의 처리를 위임자(delegate)에게 보냄 (서브클래스가 부모 클래스에게 요청을 전달하는 방법과 유사)

- 위임의 장점
  - 위임의 가장 중요한 장점은 런타임에 행동의 복합을 가능하게 하고, 복합하는 방식도 변경해 준다는 것
    - 복합을 가능하게 하려면 결국 객체 합성 처럼 퍼블릭 인터페이스에 의존하는 구조로 만들어야 할듯

- 위임의 단점
  - 객체 합성을 통해 유연성을 보장하지만 (동적), 고도로 매개변수화된 소프트웨어는 정적인 소프트웨어 구조보다 이해하기 더 어려움
    - 런타임 객체에 따라서 결과가 달라짐

- 위임이 만들어 내는 복잡함보다 단순환의 효과를 더 크게할 수 있다면 그 설계는 사용하기 좋은 설계

- 위임과 합성의 차이는?

### 상속 대 매개변수화된 타입
- 기능의 재사용에 이용할 수 있는 다른 방법이 매개변수화된 타입 (제네릭)

- 상속 vs 합성 vs 제네릭
  - 객체 합성 : 런타임에 행동을 변경할 수 있지만, 행동이 위임되기 때문에 비효율적일 수 있음
  - 상속 :  연산에 대한 기본 행동을 부모 클래스가 제공하고 이를 서브클래스에 재정의
  - 제네릭 : 클래스가 사용하는 타입을 변경하게 하는 것
    - 어떤 방법이 최적의 방법인가 하는 것은 설계와 구현 제약 사항에 따라 달라질 수 있음 



## 런타임 및 컴파일 타임의 구조를 관계짓기

## 변화에 대비한 설계





# 1.7 디자인 패턴을 고르는 방법

# 1.8 디자인 패턴 사용 방법

# 참고
- https://sonseungha.tistory.com/242
- https://gmlwjd9405.github.io/2018/09/17/class-object-instance.html
- https://dahye-jeong.gitbook.io/java/java/undefined/java-interface#undefined
