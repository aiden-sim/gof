# 서론
- 객체지향 소프트웨어 설계의 어려움
  - 설계는 지금 당장 갖고 있는 문제를 해결할 수 있어야 하지만, 나중에 생길 수 있는 문제나 추가된 요구 사항들도 수용할 수 있도록 일반적이로 포괄적이어야 함

- 경험자들이 좋은 객체지향을 설계할 수 있는 이유
   - 기초 단계에서 해결하지 않고, 전에 사용했던 해결책을 다시 사용해봄으로써 좋은 방법을 찾았다면 그 방법을 반복해서 계속 사용하게 됨
   - 반복된 패턴들은 특정 설계의 문제점들을 해결해 주고, 좀더 유연하고, 근사하며, 재사용 가능한 객체지향 소프트웨어를 만들어 줌

- 이 책의 목적
  - '디자인 패턴'이란 방식을 통해 소프트웨어 설계에서 얻은 세세한 경험들을 기록해 놓도록 하는 것

- 디자인 패턴
  - 디자인 패턴을 이용하면 좋은 설계나 아키텍처를 재사용하기 쉬워짐
  - 이미 만든 시스템의 유지보수나 문서화도 개선할 수 있고, 클래스의 명세도 정확하게 할 수 있으며, 객체 간의 상호작용 또는 설계의 의도 등까지 명확하게 정의
  - 디자인 패턴은 설계자들이 '올바른' 설계를 빨리 만들 수 있도록 도와줌

# 1.1 디자인 패턴이란?
- 패턴의 네 가지 요소
  - 1) 패턴 이름
    - 패턴의 이름을 정의해 두면 문서에서 이 이름을 사용하여 설계의 의도를 표현할 수 있게 됨
    - 이름을 갖게 되면 설계에 대한 생각을 더욱 쉽게 할 수 있고, 개발자들 간의 의사소통이 원활해짐
  - 2) 문제
    - 언제 패턴을 사용하는가를 서술하며 해결할 문제와 그 배경을 설명
  - 3) 해법
    - 설계를 구성하는 요소들과 그 요소들 간의 관계, 책임 그리고 협력 관계를 서술
    - 구체적인 부분 대신, 문제에 대한 추상적인 설명을 제공하고 문제를 해결하기 위해서 클래스나 객체들의 나열 방법을 제공
  - 4) 결과
    - 디자인 패턴을 적용해서 얻는 결과와 장단점을 서술
    - 선택하는 과정에서 또는 비용과 효과를 측정하는 과정에서 설계의 결과는 가장 중요한 부분
    - 재사용은 객체지향 설계의 주요 요소이므로, 패턴의 결과는 시스템의 유연성, 확장성, 이식성등에 커다란 영향을 줌

- 디자인 패턴은 '특정한 전후 관계에서 일반적 설계 문제를 해결하기 위해 상호교류하는 수정 가능한 객체와 클래스들에 대한 설명'

- 이 책에서는?
  - 하나의 디자인 패턴은 재사용 가능한 객체지향 설계를 만들기 위해 유용한 공통의 설계 구조에서 주요 요소들을 식별하여 이들에게 적당한 이름을 주고 추상화 함
  - 패턴에 참여하는 클래스와 그들의 인스턴스를 식별하여 역할과 그들 간의 협력 관계를 정의하고 책임을 할당함 
  - 각 디자인 패턴은 각자 맡은 객체지향 설계 문제에 집중
  - 언제 패턴을 적용할지, 다른 설계 제약을 고려하여 패턴을 적용할 수 있는지, 패턴을 사용하면 어떤 결과가 발생하는지 설명


# 1.2 스몰토크 MVC를 사용한 디자인 패턴
- MVC
  - 모델(Model) : 응용프로그램 객체
  - 뷰(View) : 스크린에 모델을 디스플레이하는 방법을 정의
  - 컨트롤러(Controller) : 사용자 인터페이스가 사용자 입력에 반응하는 방법을 정의
    - MVC 사용전에는 이러한 객체들을 모두 묶어서 하나의 객체로 처리했었음...

- MVC는 뷰와 모델 간에 등록/통지 프로토콜을 만들어 종속성을 없앤다
  - 뷰는 그 외형이 반드시 모델의 상태를 반영하도록 보장

- 감시자 패턴
  - MVC 예시에서 모델은 값이 변할 때마다 뷰에게 알려주고, 뷰들은 값을 표현하고 조작하기 위해 모델과 교류
  - 한 객체에서 일어난 변경을 다른 객체들에 반영하도록 별도의 객체를 둠으로써, 변경이 일어난 객체는 변경 반영이 필요한 다른 객체들을 알 필요가 없게끔 객체를 분리

- 복합체 패턴
  - MVC의 특징으로 뷰를 중첩시킬 수 있음
  - 복합 뷰 객체(자식)는 일반 뷰(부모) 객체가 사용되는 곳이면 동일하게 사용될 수 있음
  - 단일 객체처럼 복합 객체를 사용하고 싶을 때 사용

- 전략 패턴
  - MVC 시각적 표현 방법의 변경 없이 사용자 입력에 대한 뷰의 반응 방법을 변경할 수 있음
  - 특정 대응 전략을 구현하기 위해 View 클래스가 Controller 서브클래스의 인스턴스를 사용한다면, 다른 전략을 구현하기 위해 현재의 컨트롤러 인스턴스를 다른 종류의 컨트롤러 인스턴스로 대체만 하면 됨
  - 전략 패턴은 알고리즘을 표현하는 객체로 정적 또는 동적으로 알고리즘을 대체하고자 할 때 매우 유용한 방식

# 1.3 디자인패턴 기술하기
- 설계를 재사용하기 좋게 만들려면 설계를 하기까지의 다양한 결정, 대안, 장단점 등을 고려한 과정도 함께 적어주어야 함
- 각각의 패턴은 다음 템플릿에 따라서 구분하여 정의
- 템플릿은 디자인 패턴을 배우고 비교하며, 더 쉽게 사용할 수 있도록 일관된 구조를 제공

## 패턴 이름과 분류
- 하나의 패턴에 붙은 이름은 그 자체가 핵심을 간결하게 전달해줌

## 의도
- '이 디자인 패턴은 무엇을 하는것일까요? 의도와 논리적인 근거가 무엇일까요? 어떤 특정한 문제나 이슈를 해결하기 위한 것일까요?' 에 대한 간결한 답을 제시

## 다른 이름
- 이 패턴을 다르게 부르는 이름이 있다면, 그것을 제시

## 동기
- 설계 문제를 제시하고, 패턴 안에서 클래스나 객체 구조가 어떻게 문제를 해결하는지 설명해 주는 일종의 시나리오
- 이 시나리오는 패턴에 대한 좀더 추상화된 설명을 이해할 수 있게 도와줌

## 활용성
- '해당 패턴을 어떤 상황에 적용할 수 있을까요? 패턴이 문제로 삼는 잘못된 설계의 예는 무엇일까요? 이 상황을 어떻게 팡가할 수 있을까요?'

## 구조
- 객체 모델링 기법에 기반을 둔 표기법을 이용하여 해당 패턴에서 쓰는 클래스들을 시각적으로 나타냄
- 객체 사이에 오가는 요청과 협력 관계의 순차를 표현하기 위해서 상호작용 다이어그램도 이용

## 참여자
- 주어진 패턴을 구성하고 책임을 수행하는 클래스나 객체들을 설명

## 협력 방법
- 참여자들이 작업을 수행하기 위한 참여자들 간의 협력 관계를 정의

## 결과
- '이 패턴이 자신의 목표를 어떻게 지원할까요? 이 패턴을 이용한 결과는 무엇인고 장단점은 무엇일까요? 이 패턴을 사용하면 시스템 구조의 어떤 면을 독립적으로 다양화시킬 수 있을까요?'

## 구현
- '패턴을 구현할 때 주의해야 할 함정, 힌트, 기법 등은 무엇일까요? 특정 언어에 국한된 특이 사항은 무엇일까요?'

## 예제 코드
- C++나 스몰토크를 이용한 예제 코드

## 잘 알려진 사용예
- 실제 시스템에서 찾아볼 수 있는 패턴들의 예

## 관련 패턴
- '이 패턴과 밀접하게 관련된 다른 패턴들은 무엇일까요? 이들의 중요한 차이점은 무엇일까요? 어떤 다른 패턴에 이 패턴이 사용되어야 할까요?'

# 1.4 디자인 패턴 카탈로그
- 23개의 디자인 패턴

## Abstract Factory
- 구체적인 클래스를 지정하지 않고 관련성을 갖는 객체들의 집합을 생성하거나 서로 독립적인 객체들의 집합을 생성할 수 있는 인터페이스를 제공하는 패턴

## Adapter
- 클래스의 인터페이스를 사용자가 기대하는 다른 인터페이스로 변환하는 패턴으로, 호환성이 없는 인터페이스 때문에 함께 동작할 수 없는 클래스들이 함께 작동하도록 해 줌

## Bridge
- 구현부에서 추상층을 분리하여 각자 독립적으로 변형할 수 있게 하는 패턴

## Builder
- 복합 객체의 생성 과정과 표현 방법을 분리하여 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있게 하는 패턴

## Chain of Responsibility
- 요청을 처리할 수 있는 기회를 하나 이상의 객체에게 부여하여 요청을 보내는 객체와 그 요청을 받는 개체 사이의 결합을 피하는 패턴
- 요청을 받을 수 있는 객체를 연쇄적으로 묶고, 실제 요청을 처리할 객체를 만날 때까지 객체 고리를 따라 요청을 전달

## Command
- 요청을 객체의 형태로 캡슐화하여, 서로 요청이 다른 사용자의 매개변수화, 요청 저장 또는 로깅, 그리고 연산의 취소를 지원하게 만드는 패턴

## Composite
- 객체들의 관계를 트리 구조로 구성하여 부분-전체 계층을 표현하는 패턴으로, 사용자가 단일 객체와 복합 객체 모두 동일하게 다루도록 함

## Decorator
- 주어진 상황 및 용도에 따라 어떤 객체에 책임을 덧붙이는 패턴으로, 기능 확장이 필요할 때 서브클래싱 대신 쓸 수 있는 유연한 대안이 될 수 있음

## Facade
- 서브시스템에 있는 인터페이스 집합에 대해서 하나의 통합된 인터페이스를 제공하는 패턴으로, 서브시스템을 좀더 사용하기 편하게 만드는 상위 수준의 인터페이스를 정의

## Factory Method
- 객체를 생성하는 인터페이스는 미리 정의하되, 인스턴스를 만들 클래스의 결정은 서브클래스 쪽에서 내리는 패턴
- 팩토리 메서드 패턴에서는 클래스의 인스턴스를 만드는 시점을 서브클래스로 미룸

## Flyweight
- 크기가 작은 객체가 여러 개 있을 때, 공유를 통해 이들을 효율적으로 지원하는 패턴

## Interpreter
- 주어진 언어에 대해, 그 언어의 문법을 위한 표현 수단을 정의하고, 이와 아울러 그 표현 수단을 사용하여 해당 언어로 작성된 문장을 해석하는 해석기를 정의하는 패턴

## Iterator
- 내부 표현부를 노출하지 않고 어떤 객체 집합에 속한 원소들을 순차적으로 접근할 수 있는 방법을 제공하는 패턴

## Mediator
- 한 집합에 속해있는 객체들의 상호작용을 캡슐화하는 객체를 정의한는 패턴
- 객체들이 직접 서로를 참조하지 않도록 함으로써 객체들 사이의 소결합(loose coupling)을 촉진시키며, 개발자가 객체들의 상호작용을 독립적으로 다양화시킬 수 있게 만듬

## Memento
- 캡슐화를 위배하지 않은 채 어떤 객체의 내부 상태를 잡아내고 실체화시켜, 이후에 해당 객체가 그 상태로 다시 되돌아올 수 있도록 하는 패턴

## Observer
- 객체 사이에 일 대 다의 의존 관계를 정의해 두어, 어떤 객체의 상태가 변할 때 그 객체에 의존성을 가진 다른 객체들이 그 변화를 통지받고 자동으로 갱신될 수 있게 만드는 패턴

## Prototype
- 생성할 객체의 종류를 명세화하는 데에 원형이 되는 예시물을 이용하고, 그 원형을 복사함으로써 새로운 객체를 생성하는 패턴

## Proxy
- 어떤 다른 객체로 접근하는 것을 통제하기 위해서 그 객체의 대리자 또는 자리채움자를 제공하는 패턴

## Singleton
- 어떤 클래스의 인스턴스는 오직 하나임을 보장하며, 이 인스턴스에 접근할 수 있는 전역적인 접촉점을 제공하는 패턴

## State
- 객체의 내부 상태에 따라 스스로 행동을 변경할 수 있게끔 허가하는 패턴으로, 이렇게 하면 객체는 마치 자신의 클래스를 바꾸는 것처럼 보임

## Strategy
- 동일 계열의 알고리즘군을 정의하고 각각의 알고리즘을 캡슐화하며, 이들을 상호교환이 가능하도록 만드는 패턴
- 알고리즘을 사용하는 사용자와 상관없이 독립적으로 알고리즘을 다양하게 변경할 수 있게 함

## Template Method
- 객체의 연산에는 알고리즘의 뼈대만을 정의하고 각 단계에서 수행할 구체적 처리는 서브클래스 쪽으로 미루는 패턴
- 알고리즘의 구조 자체는 그대로 놔둔 채 알고리즘 각 단계의 처리를 서브클래스에서 정의할 수 있게 함

## Visitor
- 객체 구조를 이루는 원소에 대해 수행할 연산을 표현하는 패턴으로, 연산을 적용할 원소의 클래스를 변경하지 않고도 새로운 연상을 정의할 수 있게 함

# 1.5 카탈로그 조직화하기
- 패턴 분류 기준
  - 1


# 1.6 디자인 패턴을 이용하여 문제를 푸는 방법

# 1.7 디자인 패턴을 고르는 방법

# 1.8 디자인 패턴 사용 방법


