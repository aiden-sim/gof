## 책임 연쇄 패턴
- 핸들러 체인을 사용해서 요청을 처리한다.
- 책임은?
  - 단일 책임 원칙에서 말하는 책임 (오직 한가지 이유로 변경) 

- 구조
  - ![image](https://user-images.githubusercontent.com/7076334/150686063-ad606ac8-d0cf-49ee-a7af-db24b610f53d.png)
 


### before
```
public class Client {
    public static void main(String[] args) {
        Request request = new Request("무궁화 꽃이 피었습니다.");
        RequestHandler requestHandler = new LoggingRequestHandler();
        requestHandler.handler(request);
    }
}

// 이 코드를 수정하면 SRP 위배
public class RequestHandler {
    public void handler(Request request) {
        // 인증이 되었나?
        // 이 핸들러를 사용할 수 있는 유저인가?
        System.out.println(request.getBody());
    }
}

// 상속을 통해서 처리 (RequestHandler 의 SRP는 지켜질 수 있다.)
public class LoggingRequestHandler extends RequestHandler {
    @Override
    public void handler(Request request) {
        System.out.println("로깅");
        super.handler(request);
    }
}
```

- 로깅이 아니라 인증이 필요 하다면? 로깅도 하고 인증도 해야 된다면?
  - 복잡해 지는 이유가 Client가 핸들러를 직접 알고 제어해야 됨

### after



