## 책임 연쇄 패턴
- 요청을 보내는 쪽(sender)과 요청을 처리하는 쪽(receiver)의 분리하는 패턴

- 책임은?
  - 단일 책임 원칙에서 말하는 책임 (오직 한가지 이유로 변경) 

- 구조
  - ![image](https://user-images.githubusercontent.com/7076334/150686063-ad606ac8-d0cf-49ee-a7af-db24b610f53d.png)
    - 핸들러 체인을 사용해서 요청을 처리한다.


### before
```
public class Client {
    public static void main(String[] args) {
        Request request = new Request("무궁화 꽃이 피었습니다.");
        RequestHandler requestHandler = new LoggingRequestHandler();
        requestHandler.handler(request);
    }
}

// 이 코드를 수정하면 SRP 위배
public class RequestHandler {
    public void handler(Request request) {
        // 인증이 되었나?
        // 이 핸들러를 사용할 수 있는 유저인가?
        System.out.println(request.getBody());
    }
}

// 상속을 통해서 처리 (RequestHandler 의 SRP는 지켜질 수 있다.)
public class LoggingRequestHandler extends RequestHandler {
    @Override
    public void handler(Request request) {
        System.out.println("로깅");
        super.handler(request);
    }
}
```

- 로깅이 아니라 인증이 필요 하다면? 로깅도 하고 인증도 해야 된다면?
  - 복잡해 지는 이유가 Client가 핸들러를 직접 알고 제어해야 됨

### after
```
/**
 * Client
 */
public class Client {

    private RequestHandler requestHandler;

    public Client(RequestHandler requestHandler) {
        this.requestHandler = requestHandler;
    }

    public void doWork() {
        Request request = new Request("이번 놀이는 뽑기입니다.");
        requestHandler.handle(request);
    }

    public static void main(String[] args) {
        RequestHandler chain = new AuthRequestHandler(new LoggingRequestHandler(new PrintRequestHandler(null)));
        Client client = new Client(chain);
        client.doWork();
    }
}

/**
 * Handler
 */
public abstract class RequestHandler {

    private RequestHandler nextHandler;

    public RequestHandler(RequestHandler nextHandler) {
        this.nextHandler = nextHandler;
    }

    public void handle(Request request) {
        if (nextHandler != null) {
            nextHandler.handle(request);
        }
    }
}

/**
 * ConcreteHandler
 */
public class AuthRequestHandler extends RequestHandler {

    public AuthRequestHandler(RequestHandler nextHandler) {
        super(nextHandler);
    }

    @Override
    public void handle(Request request) {
        System.out.println("인증이 되었는가?");
        super.handle(request);
    }
}
```

- 클라이언트가 더이상 어떤 핸들러를 써야되는지 결정하지 않는다.
  - 단지 체인이 만들어 주는 곳에서 결정 
- 요청을 보내는쪽 (클라이언트)과 요청을 처리(핸들러) 하는 쪽과 디커플링 되어 있다.


### 책임 연쇄 패턴 장점과 단점
- 장점
  - 클라이언트 코드를 변경하지 않고 새로운 핸들러를 체인에 추가할 수 있다. (OCP)
  - 각각의 체인은 자신이 해야하는 일만 한다. (SRP)
  - 체인을 다양한 방법으로 구성할 수 있다.
    - 순서 가지고 있는 체인
    - 특정 핸들러에서만 조건으로 처리할 수 있게

- 단점
  - 디버깅이 조금 어려움 (핸들러가 연결되어 있어서)
  - 탐색이 어려움

### 사용 사례
- 자바
  - 서블릿 필터
  ```
  @WebFilter(urlPatterns = "/hello")
  public class MyFilter implements Filter {

      @Override
      public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
          System.out.println("게임에 참하신 여러분 모두 진심으로 환영합니다.");
          chain.doFilter(request, response);
          System.out.println("꽝!");
      }
  }
  ```
- 스프링
  - 스프링 시큐리티 필터
  ```
  @Configuration
  public class SecurityConfig extends WebSecurityConfigurerAdapter {
      @Override
      protected void configure(HttpSecurity http) throws Exception {
          http.authorizeRequests().anyRequest().permitAll().and();
      }
  }
  ```

## 커맨트 패턴
- 요청을 캡슐화 하여 호출자(invoker)와 수신자(receiver)를 분리하는 패턴

- 구조
  - ![image](https://user-images.githubusercontent.com/7076334/150688108-60c42576-6874-47cd-bf6c-e4bb21c69def.png)
    - 요청을 처리하는 방법이 바뀌더라도, 호출자의 코드는 변경되지 않는다.

### before
```
public class MyApp {
    public static void main(String[] args) {
        Button button = new Button(new Light());
        button.press();
        button.press();
        button.press();
        button.press();
    }
}

public class Button {

    private Light light;

    public Button(Light light) {
        this.light = light;
    }

    public void press() {
        light.off();
    }
}

public class Light {

    private boolean isOn;

    public void on() {
        System.out.println("불을 켭니다.");
        this.isOn = true;
    }

    public void off() {
        System.out.println("불을 끕니다.");
        this.isOn = false;
    }

    public boolean isOn() {
        return this.isOn;
    }
}

```
- Light(receiver) 의 코드가 변경되면 Button(invoker)의 영향을 받게 된다.
  - off -> buttonOff 로 변경된다면?
- 다른 invoker(MyApp)에서 Light(receiver)를 사용한다면? 중복 코드가 생긴다. ex) press()
- 코드의 변경이 자주 발생된다.
  - invoke와 receiver가 강하게 결합되어 있어서 그렇다.
  - 그래서 이 부분을 요청 자체를 캡슐화 해서 (Command) 처리

### after
```
/**
 * Invoker
 */
public class MyApp {

    private Command command;

    public MyApp(Command command) {
        this.command = command;
    }

    public void press() {
        command.execute();
    }

    public static void main(String[] args) {
        MyApp myApp = new MyApp(new GameStartCommand(new Game()));
        myApp.press();
    }
}

/**
 * Command
 */
public interface Command {
    void execute();
}

/**
 * ConcreteCommand
 */
public class GameStartCommand implements Command {

    private Game game;

    public GameStartCommand(Game game) {
        this.game = game;
    }

    @Override
    public void execute() {
        game.start();
    }
}

/**
 * Receiver
 */
public class Game {

    private boolean isStarted;

    public void start() {
        System.out.println("게임을 시작합니다.");
        this.isStarted = true;
    }
}

```
- java에는 Runnable Interface가 있다.
- 조삼모사 아닐까?
  - 버튼에서 변경되는 부분이 커멘드쪽으로 바뀐거 아닐까?
  - invoker는 변경되지 않는다. (변화되는 부분이 축소된다.)
  - Command 를 통해 재사용할 수 있다.

### 커맨트 패턴 장점과 단점
- 장점
  - 기존 코드를 변경하지 않고 새로운 커맨드를 만들 수 있다. (OCP)
  - 수신자의 코드가 변경되어도 호출자의 코드는 변경되지 않는다. (SRP)
  - 커맨드 객체를 로깅, DB에 저장(예제에서 stack), 네트워크로 전송(rmi?)하는 등 다양한 방법으로 활용할 수도 있다.
- 단점
  - 코드가 복잡하고 클래스가 많아진다.


### 사용 사례
- 자바
  - Runnable (Command)
  - 람다 / 메소드 레퍼런스
  ```
  public class CommandInJava {
    public static void main(String[] args) {
        Light light = new Light();
        Game game = new Game();
        ExecutorService executorService = Executors.newFixedThreadPool(4);
        executorService.submit(new Runnable() { // command 형태
            @Override
            public void run() {
                light.on();
            }
        });
        executorService.submit(() -> light.isOn());
        executorService.submit(light::on);
        executorService.shutdown();
    }
  }
  ```
  
 
- 스프링
  - SimpleJdbcInsert (구조가 좀 이해 안감)
  - SimpleJdbcCall (Stored Procedure)
  ```
  public class CommandInSpring {

    private DataSource dataSource;

    public CommandInSpring(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    public void add(Command command) {
        // 하나의 커맨드
        SimpleJdbcInsert insert = new SimpleJdbcInsert(dataSource)
                .withTableName("command")
                .usingGeneratedKeyColumns("id");

        // 얘가 receiver 인가?
        Map<String, Object> data = new HashMap<>();
        data.put("name", command.getClass().getSimpleName());
        data.put("when", LocalDateTime.now());
        
        insert.execute(data);
    }
  }
  ```

## 인터프리터 패턴
- 구조
  - ![스크린샷 2022-02-09 오전 5 21 45](https://user-images.githubusercontent.com/7076334/153069413-9efff7cd-490f-4377-b354-ec50016871d8.png)
  - 자주 등장하는 문제를 간단한 언어로 정의하고 재사용하는 패턴
  - Expression : 우리가 나타내는 문법
  - Terminal : 그 자체로 종료가 되는 Expression  ex) 1,2,3
  - NonTerminal : 재귀적으로 Terminal, NonTerminal Expression 참조 ex) +,-
  - Composite 패턴과 유사구조

### 인터프리터 패턴 장점과 단점
- 장점
  - 자주 등장하는 문제 패턴을 언어와 문법으로 정의할 수 있다.
  - 기존 코드를 변경하지 않고 새로운 Expression을 추가할 수 있다. 
- 단점
  - 복잡한 문법을 표현하려면 Expression과 Parser가 복잡해진다. 

### 사용 사례
- 자바
  - 자바 컴파일러
- 스프링
  - SpEL (스프링 Expression Language)  


## 이터레이터 패턴
- 구조
  - ![iterator](https://user-images.githubusercontent.com/7076334/153108926-f6716edc-ce91-47b0-978a-6ab68745024a.png)
  - 집합 객체 내부 구조를 노출시키지 않고 순회 하는 방법을 제공하는 패턴.
    - Iterator (Iterator)
    - ConcreteIterator (ArrayList$Iterator)
    - Aggregate (List)
    - ConcreateAggregate (ArrayList)

### 이터레이터 패턴 장점과 단점
- 장점
  - 집합 객체가 가지고 있는 객체들에 손쉽게 접근할 수 있다.
  - 일관된 인터페이스를 사용해 여러 형태의 집합 구조를 순회할 수 있다.

- 단점
  - 클래스가 늘어나고 복잡도가 증가한다. 

### 사용 사례
- 자바
  - java.util.Enumeration과 java.util.Iterator
  - Java StAX (Streaming API for XML)의 Iterator 기반 API

- 스프링
  - CompositeIterator 

## 중재자 패턴
- 구조
  - ![mediation](https://user-images.githubusercontent.com/7076334/153275702-9bf1c740-3298-4463-8960-6edd1027de0f.png)
  - 여러 객체들이 소통하는 방법을 캡슐화 하는 패턴

### 중재자 패턴 장점과 단점
- 장점
  - 컴포넌트 코드를 변경하지 않고 새로운 중재자를 만들어 사용할 수 있다.
  - 각각의 컴포넌트 코드를 보다 간결하게 유지할 수 있다.  
- 단점
  - 중재자 역할을 하는 클래스의 복잡도와 결합도가 증가한다.

### 사용 사례
- 자바
  - ExecutorService
  - Executor

- 스프링
  -DispatcherServlet 
  
  
## 메멘토 패턴
- 캡슐화를 유지하면서 객체 내부 상태를 외부에 저장하는 방법

- 구조
  - ![memento](https://user-images.githubusercontent.com/7076334/153711294-226d42d9-8627-4cf0-905b-990d319f0799.png)
    - 객체 상태를 외부에 저장했다가 해당 상태로 다시 복구할 수 있다.

- 사용 예
  - 문서편집기에서 undo
  - 게임에서 pause

### before
```
public class Client {

    public static void main(String[] args) {
        Game game = new Game();
        game.setRedTeamScore(10);
        game.setBlueTeamScore(20);

        int blueTeamScore = game.getBlueTeamScore();
        int redTeamScore = game.getRedTeamScore();

        Game restoredGame = new Game();
        restoredGame.setBlueTeamScore(blueTeamScore);
        restoredGame.setRedTeamScore(redTeamScore);
    }
}
```
- 캡슐화가 깨진다.
  - 클라이언트가 게임에 있는 내부정보(socre)가 어떤게 있는지 알고 있어야 됨
  - 게임에서 내부 정보가 변경되거나 추가될때 클라이언트가 세부정보에 의존하고 있기 때문에 변경됨

- 역할
  - Originator : 상태를 저장하고 복원하고 싶은 원본 데이터 (Game)
    - 생성과 복원 기능 제공해 줘야됨 
  - Memento(immutable) : 내부 정보를 Memento로 추상화
  - CareTaker : Originator의 내부정보를 저장 후 복원 (내부 정보는 Memento를 이용함) 



### after
/**
 * CareTaker
 */
public class Client {

    public static void main(String[] args) {
        Game game = new Game();
        game.setBlueTeamScore(10);
        game.setRedTeamScore(20);

        GameSave save = game.save();

        game.setBlueTeamScore(12);
        game.setRedTeamScore(22);

        game.restore(save);

        System.out.println(game.getBlueTeamScore());
        System.out.println(game.getRedTeamScore());
    }
}

```
/**
 * Originator
 */
public class Game {

    private int redTeamScore;

    private int blueTeamScore;

    public int getRedTeamScore() {
        return redTeamScore;
    }

    public void setRedTeamScore(int redTeamScore) {
        this.redTeamScore = redTeamScore;
    }

    public int getBlueTeamScore() {
        return blueTeamScore;
    }

    public void setBlueTeamScore(int blueTeamScore) {
        this.blueTeamScore = blueTeamScore;
    }

    public GameSave save() {
        return new GameSave(this.blueTeamScore, this.redTeamScore);
    }

    public void restore(GameSave gameSave) {
        this.blueTeamScore = gameSave.getBlueTeamScore();
        this.redTeamScore = gameSave.getRedTeamScore();
    }
}

/**
 * Memento (immutable)
 */
public final class GameSave {

    private final int blueTeamScore;

    private final int redTeamScore;

    public GameSave(int blueTeamScore, int redTeamScore) {
        this.blueTeamScore = blueTeamScore;
        this.redTeamScore = redTeamScore;
    }

    public int getBlueTeamScore() {
        return blueTeamScore;
    }

    public int getRedTeamScore() {
        return redTeamScore;
    }
}
```
- GameSave(Memento)
  - immutable 해야 되기 때문에 인스턴스 변수 final로 사용 
  - 생성자로만 생성하고 게터만 제공
- Game(Originator)
  - 저장 / 복원 
- Client(CareTaker)


### 메멘토 패턴 장점과 단점
- 장점
  - 객체 상태가 바뀌어도 클라이언트 코드는 변경되지 않는다. 
  - 캡슐화를 지키면서 상태 객체 상태 스냅샷을 만들 수 있다. (OCP)
  - 객체 상태 저장하고 또는 복원하는 역할을 CareTaker에게 위임할 수 있다. (SRP)

- 단점
  - 많은 정보를 저장하는 Memento를 자주 생성하는 경우 메모리 사용량에 많은 영향을 줄 수 있다.
    - CareTaker가 관리하는 역할을 할 수도 있다. 


### 사용 사례
- 자바
  - 객체 직렬화 (Serializable)
    - 직렬화를 통해 byteStream 형태로 저장
    - 역직렬화를 통해 파일,네트워크로 복원할 수 있다.
    ```
    public class MementoInJava {

      public static void main(String[] args) throws IOException, ClassNotFoundException {
          // TODO Serializable
          Game game = new Game();
          game.setRedTeamScore(10);
          game.setBlueTeamScore(20);

          // TODO 직렬화
          try(FileOutputStream fileOut = new FileOutputStream("GameSave.hex"); // 헥스 에디터
          ObjectOutputStream out = new ObjectOutputStream(fileOut))
          {
              out.writeObject(game);
          }

          game.setBlueTeamScore(25);
          game.setRedTeamScore(15);

          // TODO 역직렬화
          try(FileInputStream fileIn = new FileInputStream("GameSave.hex");
              ObjectInputStream in = new ObjectInputStream(fileIn))
          {
              game = (Game) in.readObject();
              System.out.println(game.getBlueTeamScore());
              System.out.println(game.getRedTeamScore());
          }
      }
    }
    ```
    - 제약사항
      - byteStream을 CareTaker에서 관리 해야됨
      - originator에서 직렬화/역직렬화를 지원해야됨
      - 역지렬화의 보안 이슈
      - 성능 고려

- java.util.Date (좀 애매)
  



### 기타
- 목적과 의도 해결방법이 중요하지 구현이 중요한것은 아니다.



  
