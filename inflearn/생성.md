### 팩토리 메소드 패턴
- 구체적으로 어떤 인스턴스를 만들지는 서브 클래스가 정한다.

- BlackShip을 생산했다가 WhiteShip에 대한 주문이 들어 온다면?
  - 코드 내부에서 if/else 로 분기가 계속 생길것이다.
- 그러다가 여러 종류의 배가 추가된다면?
  - Concrete class에 담아두기 복잡해 진다

- 해결책은?
  - 추상화된 팩토리를 만든다.
  
- 구조
  - ![스크린샷 2021-12-13 오후 11 18 21](https://user-images.githubusercontent.com/7076334/145828781-985d2ec3-c7d5-457a-a204-e50a51309805.png)
  - 여기서는 인터페이스 default 메서드를 이용해서 기본 기능 구현 하고 변경되는 부분만 ConcreteCreator에서 구현 (템플릿 메서드)
  - 확장한 유연한 구조로 만들어 진다.

## Before

```
public class ShipFactory {

    public static Ship orderShip(String name, String email) {
        // validate
        if (name == null || name.isBlank()) {
            throw new IllegalArgumentException("배 이름을 지어주세요.");
        }
        if (email == null || email.isBlank()) {
            throw new IllegalArgumentException("연락처를 남겨주세요.");
        }

        prepareFor(name);

        Ship ship = new Ship();
        ship.setName(name);

        // Customizing for specific name
        if (name.equalsIgnoreCase("whiteship")) {
            ship.setLogo("\uD83D\uDEE5️");
        } else if (name.equalsIgnoreCase("blackship")) {
            ship.setLogo("⚓");
        }

        // coloring
        if (name.equalsIgnoreCase("whiteship")) {
            ship.setColor("whiteship");
        } else if (name.equalsIgnoreCase("blackship")) {
            ship.setColor("black");
        }

        // notify
        sendEmailTo(email, ship);

        return ship;
    }

    private static void prepareFor(String name) {
        System.out.println(name + " 만들 준비 중");
    }

    private static void sendEmailTo(String email, Ship ship) {
        System.out.println(ship.getName() + " 다 만들었습니다.");
    }

}


public class Ship {

    private String name;

    private String color;

    private String logo;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getColor() {
        return color;
    }

    public void setColor(String color) {
        this.color = color;
    }

    public String getLogo() {
        return logo;
    }

    public void setLogo(String logo) {
        this.logo = logo;
    }

    @Override
    public String toString() {
        return "Ship{" +
                "name='" + name + '\'' +
                ", color='" + color + '\'' +
                ", logo='" + logo + '\'' +
                '}';
    }
}

```
- 만약 새로운 제품이 추가 된다면? 요구사항에 따라서 제품(Ship)의 항목들이 변경될 수 있다.
  - OCP 위배 (변경에 닫혀 있지 않다.)


## After
```
/**
 * Creator
 */
public interface ShipFactory {

    default Ship orderShip(String name, String email) {
        validate(name, email);
        prepareFor(name);
        Ship ship = createShip();
        sendEmailTo(email, ship);
        return ship;
    }

    void sendEmailTo(String email, Ship ship);

    Ship createShip();

    private void validate(String name, String email) {
        if (name == null || name.isBlank()) {
            throw new IllegalArgumentException("배 이름을 지어주세요.");
        }
        if (email == null || email.isBlank()) {
            throw new IllegalArgumentException("연락처를 남겨주세요.");
        }
    }

    private void prepareFor(String name) {
        System.out.println(name + " 만들 준비 중");
    }
}


/**
 * ConcreateCreator
 */
public class WhiteshipFactory extends DefaultShipFactory {

    @Override
    public Ship createShip() {
        return new Whiteship();
    }
}


/**
 * Product
 */
public class Ship {

    private String name;

    private String color;

    private String logo;

    private Wheel wheel;

    private Anchor anchor;


/**
 * ConcreteProduct
 */
public class Whiteship extends Ship {

    public Whiteship() {
        setName("whiteship");
        setLogo("\uD83D\uDEE5️");
        setColor("white");
    }
}

/**
 * Clinet (의존성 주입)
 */
public class Client {

    public static void main(String[] args) {
        Client client = new Client();
        client.print(new WhiteshipFactory(), "whiteship", "keesun@mail.com");
        client.print(new BlackshipFactory(), "blackship", "keesun@mail.com");
    }

    // 이 코드는 인터페이스 기반으로 만들었기 때문에 변경되지 않는다.
    private void print(ShipFactory shipFactory, String name, String email) {
        System.out.println(shipFactory.orderShip(name, email));
    }
}
```
- Diagram
  - ![스크린샷 2021-12-13 오후 11 45 12](https://user-images.githubusercontent.com/7076334/145833014-8889a479-51a7-4e9b-b31c-f34cb5ef4cd2.png)



- BlackShip을 만든다면 WhiteShip은 변경되지 않기 때문에 변경에 닫혀있다. (OCP 만족)
- Clinet 코드는 변경되지 않았느냐?
  - 그래서 의존성 주입을 통해 해결
- java9 부터 interface에서 private method 사용 가능
- 계층 구조는 클래스-클래스, 인터페이스-클래스, 인터페이스-추상클래스-클래스 상관 없다.
  - 중요한건 **구체적인 팩토리** 안에서 **구체적인 제품**을 만들어 낸다. 


## 팩토리 메소드 패턴 복습
- 팩토리 메서드 패턴의 장점과 단점
  - 장점 : OCP를 적용해서 기존 코드를 건들지 않고 새로운 종류의 인스턴스 확장 가능. (Creator와 Product을 느슨하게 가져갔기 때문에 가능)
  - 단점 : 각자의 역할을 나누다 보니 처음보다 클래스 갯수 늘어남

- OCP 객체지향 원칙을 설명
  - 변경에 닫혀 있다는 것은 기존 코드를 바꾸지 않고 새로운 기능을 확장할 수 있는 객체지향 원칙
    - ex) WhiteShip, BlackShip 

## 사용 예

- Calendar
  - Simple Factory 패턴
  ```
  public class SimpleFactory {

      public Object createProduct(String name) {
          if (name.equals("whiteship")) {
              return new Whiteship();
          } else if (name.equals("blackship")) {
              return new Blackship();
          }

          throw new IllegalArgumentException();
      }
  }
  ```

- BeanFactory (Spring)
```
public class SpringBeanFactoryExample {

    public static void main(String[] args) {
        BeanFactory xmlFactory = new ClassPathXmlApplicationContext("config.xml");
        String hello = xmlFactory.getBean("hello", String.class);
        System.out.println(hello);

        BeanFactory javaFactory = new AnnotationConfigApplicationContext(Config.class);
        String hi = javaFactory.getBean("hello", String.class);
        System.out.println(hi);
    }
}
```
  - BeanFactory (Creator)
  - ClassPathXmlApplicationContext, AnnotationConfigApplicationContext (ConcreteCreator)
  - getBean (Product)
  - Custom Bean (ConcreteProduct)



### 추상 팩토리 패턴

### 빌더 패턴
